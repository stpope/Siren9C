<H3>Siren 9C Workbook</H3><hr><h3 id="IntroductiontothisOutline">1 - Introduction to this Outline</h3>Introduction to the Siren 9.0 Workbook</br>
</br>
Welcome to Siren 9.0!</br>
</br>
What is this?</br>
</br>
This document is the Siren user's guide. This manual is available as a web site for on-line browsing (see http://FASTLabInc.com/Siren or https://github.com/stpope/Siren9C), as a PDF file for printing, or from within the Smalltalk run-time system in a workspace outline view (the best way to read it).</br>
</br>
Throughout this document, there are executable Smalltalk expressions, which are generally enclosed in square brackets, as in</br>
</br>
&emsp;[ some code ]</br>
</br>
If you are reading this text within Smalltalk, you can select this text by double-clicking on either of the square brackets, and then using the pop-up contextual menu to evaluate the expression (see the menu items "do it," "print it,"  "inspect it," or "debug it"). There is a more complete description of how to use these features in the section below on getting started. </br>
</br>
Who is this intended for?</br>
</br>
Before we start, readers should be reminded that Siren is a Smalltalk-80-based programming framework for developing music/sound applications. Siren is not an application in itself. The ideal user will be literate in some object-oriented programming language, and possess at least a moderate understanding of musical terms.</br>
</br>
For those unfamiliar with the syntax of Smalltalk, there is a section at the end of this outline that introduces the language.</br>
</br>
How do I use this tool?</br>
</br>
If you're reading this within Siren, the window is a workspace-list view. You can select different pages of the outline from the list above, and scroll within a page in this lower view. You can move the horizontal divider line (above) if you want a smaller topic list and larger text view.</br>
</br>
----</br>
</br>
Stephen Travis Pope (stephen@HeavenEverywhere.com)</br>
Munich, October 1984 - Santa Barbara, May 2007 - May 2020 - Ojai, December, 2022</br>
</p><hr><h3 id="Siren9">2 - Siren 9</h3>What is Siren?</br>
</br>
The Siren system is a general-purpose software framework for music and sound composition, processing, performance, and analysis; it is a collection of about 350 classes written in Smalltalk-80 (40 kLOC or so). Siren 9.0 works on VisualWorks Smalltalk (available for free for non-commercial use); Siren 9C works (to varying degrees) on Cuis and Squeak, two free implementations. Siren-on-Squeak supports streaming I/O via OpenSoundControl (OSC), MIDI, and multi-channel audio ports, but unfortauntely not the Siren GUI tools.  Siren-on-Cuis supports the GUI tools, but not the MIDI I/O facilities (stay tuned). At present, Cuis is expected to be the main platform for on-going development.</br>
</br>
The Siren release is available via the web from the URL https://github.com/stpope/Siren9C. Note that you need a Smalltalk virtual machine and run-time to use Siren; you can get one of these for your desired host platform from https://github.com/OpenSmalltalk/opensmalltalk-vm/releases</br>
</br>
Siren is a programming framework and tool kit; the intended audience is Smalltalk developers, or users willing to learn Smalltalk in order to write their own applications. The built-in applications are meant as demonstrations of the use of the libraries, rather than as end-user applications. Siren is not a MIDI sequencer, nor a score notation editor, through both of these applications would be easy to implement with the Siren framework.</br>
</br>
There are several elements to Siren:</br>
&emsp;the Smoke music representation language</br>
&emsp;&emsp;(music magnitudes, events, event lists, generators, functions, and sounds);</br>
&emsp;voices, schedulers and I/O drivers</br>
&emsp;&emsp;(real-time and file-based voices, sound, score file, OSC, and MIDI I/O);</br>
&emsp;user interface components for musical applications</br>
&emsp;&emsp;(UI framework, tools, and widgets);</br>
&emsp;several built-in applications </br>
&emsp;&emsp;(editors and browsers for Smoke objects); and</br>
&emsp;external library interfaces for streaming I/O and DSP math</br>
&emsp;&emsp;(sound/MIDI I/O, fast FFT, CSL & Loris sound analysis/resynthesis packages )</br>
</br>
Each of these components is described below in its own section of this document.</br>
</br>
If you can read a bit of Smalltalk and want a quick tour before proceeding, read the condensed "Standard Siren Demo" that's at the end of this outline.</br>
</br>
Where's More Documentation?</br>
</br>
Siren and its predecessors and components (ARA, DoubleTalk, HyperScore ToolKit, and MODE) are documented in several extended book chapters and articles:</br>
&emsp;-- "Squeak: Open Personal Computing and Multimedia" (Mark Guzdial and Kim </br>
&emsp;&emsp;Rose, eds, Prentice-Hall, 2002);</br>
&emsp;--  "Musical Signal Processing" (C. Roads, S. T. Pope, G. DePoli, and A. Piccialli, </br>
&emsp;&emsp;eds. Swets & Zeitlinger, 1997);</br>
&emsp;--  "The Interim DynaPiano" in "Computer Music Journal" 16:3, Fall, 1992 </br>
&emsp;&emsp;(also on the CMJ Web site);</br>
&emsp;-- "The Well-Tempered Object: Musical Applications of Object-Oriented Software </br>
&emsp;&emsp;Technology" (S. T. Pope, ed. MIT Press, 1991);</br>
&emsp;-- Proceedings of the 1986, 1987, 1989, 1991, 1992, 1994, 1996, 1997, 2003 </br>
&emsp;&emsp;International Computer Music Conferences (ICMCs); and </br>
</br>
There are more MODE- and Smoke-related documents (including the above references) in the directory ftp://FASTLabInc.com/Siren/Doc or as PDF files on the page http://HeavenEverywhere.com/stp/publs.html.</br>
</br>
The official Siren home page is,</br>
&emsp;http://FASTLabInc.com/Siren</br>
</br>
Here are the on-line Docs: The best in-depth doc (book chapter) is in,</br>
&emsp;http://FASTLabInc.com/Siren/Doc/SirenBookChapter.pdf</br>
</br>
The read the demo code workbook (this text), go to,</br>
&emsp;http://FASTLabInc.com/Siren/Siren9C.Workbook.html</br>
</br>
If you like to read manuals, take a look at the auto-generated Siren 7.5 manual,</br>
&emsp;http://FASTLabInc.com/Siren/Manual</br>
</br>
Watch the detailed Siren demos at,</br>
&emsp;https://vimeo.com/120751122</br>
&emsp;https://vimeo.com/421319630</br>
</br>
History</br>
</br>
Siren and its predecessors stem from music systems that I've developed in the process of composing and realizing my music. Of the early ancestors, the MShell (1980-83) was the score processing shell used for "4" (1980-82); ARA (1982-4) was an outgrowth of the Lisp system used for "Bat out of Hell" (1983); the DoubleTalk system (1984-7) was based on the Smalltalk-80-based Petri net editing system used for "Requiem Aeternam dona Eis" (1986); the HyperScore ToolKit's various versions (1986-90) were used (among others) for "Day" (1988), and the MODE (1990-96) was developed to realize "Kombination XI" (1990) and "Paragraph 31: All Gates are Open" (1993).</br>
</br>
Siren-on-Squeak (1996-2002) was a simple re-implementation of the MODE in the Squeak version of Smalltalk; it added the representations and tools I needed for "Four Magic Sentences" (1998-2000). Siren 7.4 added tools from the realizations of "Eternal Dream" (2002) and "Leur Songe de la Paix" (2003). The newest release incorporates new code from "Jerusalem's Secrets" and "Ora penso invece che il mondo..." (2005-6). In each of these cases, some amount of effort was spent--after the completion of the composition--to make the tools more general-purpose. </br>
</br>
Portability</br>
</br>
The Smalltalk portion of Siren is 100% cross-platform, and the DLLCC external interfaces to sound file, MIDI, and sound streaming I/O use cross-platform libraries. There are a few places (Sound play command and aubio interfaces) that assume UNIX shell commands can be run form within Smalltalk; I'm not certain hiow these port to Windows.</br>
</br>
The core of Siren is not dependent on the dialect of Smalltalk, and in fact, runs well in Squeak and Cuis. The bulk of the interactive tools and GUIs are based on my own display list graphics framework, and are thus also portable. The actual integrated applications and GUIs in Siren 9.0 use VisualWorks-specific application model classes, though.  The porting of the GUIs to Cuis is in-progress at the time of this writing.</br>
</p><hr><h3 id="GettingStartedusingSiren">3 - Getting Started using Siren</h3>Getting Started with Siren</br>
</br>
Depending on what your background, you may take any one of several paths to get started with Siren. </br>
</br>
RTFM: Please read the in-depth book chapter,</br>
&emsp;http://FASTLabInc.com/Siren/Doc/SirenBookChapter.pdf</br>
</br>
If you're impatient to see what Siren can do, jump ahead to the demo script near the end of this outline.</br>
</br>
If you're a literate programmer, but unfamiliar with the Smalltalk language or environment, skip ahead to the short introduction to reading the Smalltalk language at the end of this document.</br>
</br>
If you're an experienced Smalltalk developer, I encourage you to read through the rest of this document, and use the in-line code examples as starting points to explore the implementation classes. Use the pop-up menu item "debug it" to get right into the code.</br>
</br>
Executing code: do-it, print-it, inspect-it and debug-it</br>
</br>
As a very simple introduction, look at the following line of code</br>
&emsp;3 + 4</br>
this is a perfectly well-formed Smalltalk program. To execute it, you simply have to select the text, and then use the pop-up contextual menu to compile and run it; we call this "do-it" in the menu. Try selecting the above line and selecting the menu item "do-it."</br>
</br>
You might notice that nothing visible happened. The system happily compiled and executed the program, but then threw away the result. To print the result object from an expression, use the menu item "print-it." Try this again with the above example code. This should now have printed the string "7" at the end of the text you selected.</br>
</br>
To make text selection easier in this outline, I generally enclose text that's intended as a code example in square brackets (to make selecting the code easier -- you simply need to click on the opening or closing brackets). In many cases, I also place a "d,", "p," "i," or "db" after the text to give you a hint as to whether to do-it, print-it, inspect-it, or debug-it. Try this on the examples below.</br>
</br>
&emsp;[ 3 + 4 ] d</br>
&emsp;[ 3 + 4 ] p</br>
</br>
&emsp;[ 100 factorial ] p</br>
&emsp;[ 100 factorial ] i</br>
</br>
Now try looking at the code of a Siren event list example; say "debug-it" to the expression below, which will bring up the code in a debugger; in this view, use the top-left menu bar button to "step-into" the block; now you'll be looking at the randomExample: method itself. You can use the 2nd button from the left to single step through this method, inspecting the objects in use with the inspectors at the bottom of the debugger.</br>
</br>
&emsp;[ EventList randomExample: 20 ] db</br>
</p><hr><h3 id="SirenSetupandTesting">4 - Siren Setup and Testing</h3>Setting up Siren</br>
</br>
To test the Siren set-up and I/O, open the configuration/test panel,</br>
</br>
&emsp;[SirenSession openUtility] d </br>
</br>
You can see the system configuration and test the MIDI, sound file, and sound IO here. If you use MIDI, use the left row of buttons to set it up and test it. The 2nd row of buttons is used to test sound IO.  There's a section below in this workbook about the Siren utility and transport panes.</br>
</br>
The right-most buttons are important utilities. The "clean up" button stops the scheduler and shuts down MIDI and sound IO (for use in an emergency).</br>
</br>
Special init</br>
</br>
See the method SirenUtility class initialize, with which you can customize Siren so that it finds your devices, servers, and data files. See especially the lines,</br>
</br>
&emsp;DefaultMIDIIn := 4.&emsp;&emsp;&emsp;&emsp;&emsp;"Tune these to your setup"</br>
&emsp;DefaultMIDIOut := 10.</br>
&emsp;DefaultOSCHost := #[127 0 0 1].</br>
&emsp;DefaultOSCPort := 54321.</br>
&emsp;Verbosity := 1.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"0 = pretty silent, only error logging;</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 1 = medium-verbose IO interface logging; </br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 2 = full scheduler and verbose interface logging"</br>
&emsp;[...]</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"Set search paths"</br>
&emsp;self addDir: 'Databases' to: SoundDir.&emsp;"STP-specific"</br>
&emsp;self addDir: '3-Credo/*' to: SoundDir.&emsp;"You can add using wildcards"</br>
</br>
Setting up the External Interfaces</br>
</br>
Siren uses several external interfaces (based on the user primitives) for access to external data and I/O. The Smalltalk code for these interfaces is in the category MusicIO-External. The external libraries Siren uses are:</br>
</br>
&emsp;Streaming MIDI I/O -- PortMidi -- see http://www.cs.cmu.edu/~music/portmusic</br>
</br>
(In the past there were several more, but luckily sound I/O, FFT and several other facilities have been included in recent Smalltalks.)</br>
</br>
You need to have these libraries installed (normally in a directory such as /usr/local/lib), and compile and link the C-language interface libraries in the subdirectory DLLCC for sound or MIDI I/O to work with Siren. Binaries are available for Mac OSX. There are full sources and pre-compiled versions of the required libraries on the CSL web site; look at http://FASTLabInc.com/CSL.</br>
</br>
To get CSL, &emsp;http://FASTLabInc.com/CSL</br>
</br>
</br>
Testing MIDI I/O</br>
This will open the MIDI driver and play a note; printing messages to the Transcript.</br>
&emsp;[MIDIPort testANote]</br>
Test this using a MIDI dump utility (such as MIDIMonitor), or a soft-synth, or outboard MIDI hardware. There are many other tests in class MIDIPort.</br>
</br>
Testing OpenSoundControl output</br>
The following example will send out a few OSC messages; test it with a dumpOSC utility, or with the CSL OSC server example. There are many other tests in class OSCVoice.</br>
&emsp;[OSCVoice vSOSExample3]</br>
</br>
Testing sound file I/O -- VisualWorks only -- </br>
This will print diagnostics and a few rows of sample values to the Transcript. There are more examples ion class SoundFile.</br>
&emsp;[LibSndFileInterface example1: 'a.snd']</br>
</br>
Testing streaming sound I/O</br>
This will report to the Transcript; lsee also the examples in class SoundPort.</br>
&emsp;[PortAudioInterface example1]</br>
</br>
Testing the Siren scheduler</br>
To test the built-in real-time scheduler, try the following block, which will display colored rectangles on the top window for 5 seconds, then refresh the screen.</br>
&emsp;[ActionEvent playExample]</br>
</br>
MIDI/Sound Configuration</br>
</br>
Siren's MIDI support depends on a platform-independent interface class that talks to VM-side primitives that talk to OS-level device drivers. There are clas ssettings in MIDIPort for the default I/O devices. The same applies to SoundPort.</br>
</br>
Smalltalk Options</br>
</br>
There are several configurable parts to Siren. Class SirenUtility is the general place to find utility messages related to Siren set-up and global variables. Look at its class variables and initialization method. </br>
</br>
Several of the voice classes have "default" methods that return a default instance. Look at MIDIVoice default, and Voice default.</br>
</br>
Siren looks in default directory for scores and sound files. By default this is called "Data" and is a sub-folder of the folder where the virtual image is executing. There are methods in class SirenUtility to change this. </br>
</br>
Useful Utilities</br>
</br>
There are several sound/MIDI utilities that Siren users generally need; these include:</br>
&emsp;a MIDI dump utility such as MIDIMonitor from Snoize;</br>
&emsp;an OSC dump utility such as dumpOSC from CNMAT;</br>
&emsp;an OSC send script such as sendOSC from CNMAT; and</br>
&emsp;an audio patching utility such as Jack or Audio Hijack.</br>
</br>
Siren House-keeping</br>
</br>
To clear out temp. event lists, use,</br>
&emsp;[SirenSession flushTempEventLists]</br>
or to flush all,</br>
&emsp;[SirenSession flushAllEventLists]</br>
</br>
To flush and close down the scheduler,</br>
&emsp;[Schedule interrupt; flush; release]</br>
</br>
To send MIDI all notes off, flush ports, throw away open ports, clear out temp event lists, etc.</br>
&emsp;[MIDIPort cleanUp]</br>
</br>
Check here to see if there are any left-over objecgts being held onto,</br>
&emsp;[DependentsFields inspect]</br>
</p><hr><h3 id="SirenDesignOverview">5 - Siren Design Overview</h3>Siren Design Notes</br>
</br>
There are several elements to Siren:</br>
&emsp;the Smoke music representation language</br>
&emsp;&emsp;(music magnitudes, events, event lists, generators, functions, and sounds);</br>
&emsp;voices, schedulers and I/O drivers</br>
&emsp;&emsp;(real-time and file-based voices, sound and MIDI I/O);</br>
&emsp;user interface components for musical applications</br>
&emsp;&emsp;(extended graphics framework, layout managers, UI tools and widgets); and</br>
&emsp;several built-in applications</br>
&emsp;&emsp;(editors and browsers for Siren objects).</br>
</br>
Siren Design Patterns</br>
</br>
To understand Siren's design, you should be familiar with the terminology of object-oriented design patterns, as laid out in the books "Design Patterns: Elements of Reusable Object-Oriented Software" (Gamma, Helm, Johnson, and Vlissides, Addison-Wesley 1995), and "The Design Patterns Smalltalk Companion" (Alpert, Brown, and Woolf, Addison-Wesley 1998).</br>
</br>
The following list introduces the design patterns found in Siren, and gives the parts of the system where they are used and a brief definition of each.</br>
</br>
Composite -- events/event lists, display items/display lists -- class structure for building hierarchies of objects</br>
</br>
Adaptor -- voices, ports, graphics -- interface objects translate between message protocol "languages"</br>
</br>
Singleton -- ports, scheduler, external interfaces -- a class is limited to having a single well-known instance.</br>
</br>
Decorator -- event modifiers, voices, layout -- one object "wraps" another and forwards messages sent to it.</br>
</br>
Observer -- MVC, MIDI -- an object registers istelf as an "observer" of some aspect of another object, wanting to get update messages when the observed object changes.</br>
</br>
Strategy -- layout managers, event generators, voices -- a set of classes provide a family of algorithms that encapsulate their client objects.</br>
</br>
Proxy -- voices, ports, Smoke -- one object serves as a representative of another in some context.</br>
</br>
Chain of Responsibility -- MVC, voices, input -- object-oriented recursion iterates through tree structures using composed command objects.</br>
</br>
Visitor -- Smoke, voices, graphics -- active objects traverse data structures operating on them.</br>
</br>
Double-dispatching -- Smoke -- polymorphic operators support mixed-mode operations among families of classes.</br>
</br>
Multi-threading -- scheduler</br>
</br>
The Siren Class Categories</br>
</br>
The list below is the class categories (akin to subpackages) in the Siren namespace. The same list is a class message (categoryList) in class SirenUtility.</br>
</br>
Music-Models-Representation -- abstract music magnitude models</br>
Music-Models-Implementation -- music magnitude implementation classes</br>
Music-Events -- central event classes, EventLists</br>
Music-EventGenerators -- EventGenerators: chords, clouds, etc.</br>
Music-EventModifiers -- EventModifiers: rubato, swell</br>
Music-Functions -- functions of time</br>
Music-Sound -- abstract and concrete sound classes</br>
Music-Support -- Scheduler, Utility, Session classes, abstract device, port and editor models</br>
Music-PitchClasses -- Pitch classes (octave-independent pitch notation), chords and key signatures</br>
Music-PitchScales -- Scales and harmony</br>
</br>
MusicIO-External -- External interfaces to PortAudio, PortMIDI, LibSndFile, etc.</br>
MusicIO-MIDI -- MIDI voices and devices</br>
MusicIO-OSC -- OSC streams</br>
MusicIO-Sound -- Sound ports</br>
MusicIO-Voices -- Voice hierarchy</br>
</br>
MusicUI-DisplayLists -- Core display items and list</br>
MusicUI-DisplayListViews -- Basic DL views</br>
MusicUI-Editors -- Music editors and support</br>
MusicUI-Functions -- Function editors</br>
MusicUI-Layout -- Layout managers for various notations</br>
MusicUI-Sound -- Sound and spectrum views</br>
</br>
MusicApps-CSL -- Support for the CREATE Signal Library (CSL)</br>
MusicApps-Loris -- Support for the Loris analysis/resynthesis package</br>
MusicApps-LPC -- Rudiomentary support for linear predictive coding</br>
MusicApps-SHARC -- Readers for the Sandell Harmonic Archive timbre database</br>
</br>
There are separate sub-namespaces for the SWIG-generated CSL and Loris classes.</br>
</br>
The primary class hierarchies of Siren are given below grouped into categories. The text indentation signifies sub/super-class relationships, and instances variable names are shown.</br>
</br>
Music Magnitude Models</br>
</br>
&emsp;Magnitude</br>
&emsp;&emsp;MusicMagnitude -- value</br>
&emsp;&emsp;&emsp;MusicModel -- class generality table</br>
&emsp;&emsp;&emsp;&emsp;Chroma</br>
&emsp;&emsp;&emsp;&emsp;&emsp;ModeMember</br>
&emsp;&emsp;&emsp;&emsp;&emsp;Pitch</br>
&emsp;&emsp;&emsp;&emsp;Chronos</br>
&emsp;&emsp;&emsp;&emsp;&emsp;Duration</br>
&emsp;&emsp;&emsp;&emsp;&emsp;Meter</br>
&emsp;&emsp;&emsp;&emsp;Ergon</br>
&emsp;&emsp;&emsp;&emsp;&emsp;Amplitude</br>
&emsp;&emsp;&emsp;&emsp;Positus</br>
&emsp;&emsp;&emsp;&emsp;&emsp;Directionality</br>
&emsp;&emsp;&emsp;&emsp;&emsp;Position</br>
&emsp;&emsp;&emsp;&emsp;&emsp;Spatialization</br>
</br>
Music Magnitude Implementations</br>
</br>
&emsp;Magnitude</br>
&emsp;&emsp;MusicMagnitude -- value</br>
&emsp;&emsp;&emsp;ConditionalDuration</br>
&emsp;&emsp;&emsp;NominalMagnitude</br>
&emsp;&emsp;&emsp;&emsp;SymbolicLoudness</br>
&emsp;&emsp;&emsp;&emsp;SymbolicPitch</br>
&emsp;&emsp;&emsp;NumericalMagnitude</br>
&emsp;&emsp;&emsp;&emsp;HertzPitch</br>
&emsp;&emsp;&emsp;&emsp;IntervalMagnitude</br>
&emsp;&emsp;&emsp;&emsp;&emsp;MIDIPitch</br>
&emsp;&emsp;&emsp;&emsp;&emsp;MIDIVelocity</br>
&emsp;&emsp;&emsp;&emsp;MSecondDuration</br>
&emsp;&emsp;&emsp;&emsp;&emsp;SecondDuration</br>
&emsp;&emsp;&emsp;&emsp;RatioMagnitude -- relative</br>
&emsp;&emsp;&emsp;&emsp;&emsp;RatioDuration</br>
&emsp;&emsp;&emsp;&emsp;&emsp;RatioLoudness</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;DBLoudness</br>
&emsp;&emsp;&emsp;&emsp;&emsp;RatioPitch</br>
&emsp;&emsp;&emsp;OrdinalMagnitude -- table</br>
&emsp;&emsp;&emsp;&emsp;Length</br>
&emsp;&emsp;&emsp;&emsp;Sharpness</br>
&emsp;&emsp;&emsp;PField -- name  field</br>
</br>
Events</br>
</br>
&emsp;AbstractEvent -- properties</br>
&emsp;&emsp;DurationEvent -- duration</br>
&emsp;&emsp;&emsp;ActionEvent -- action</br>
&emsp;&emsp;&emsp;MusicEvent -- pitch  loudness  voice</br>
&emsp;&emsp;&emsp;&emsp;EventList -- events  index  startedAt</br>
</br>
EventLists</br>
</br>
&emsp;AbstractEvent -- properties</br>
&emsp;&emsp;DurationEvent -- duration</br>
&emsp;&emsp;&emsp;MusicEvent -- pitch  loudness  voice</br>
&emsp;&emsp;&emsp;&emsp;EventList -- events  index  startedAt</br>
&emsp;&emsp;&emsp;&emsp;&emsp;EventGenerator</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Cloud -- density</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;DynamicCloud</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;SelectionCloud</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;DynamicSelectionCloud</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Cluster</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Chord -- root  inversion</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Arpeggio -- delay</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Roll -- number  delta  noteDuration</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Trill</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Ostinato -- list  playing  process</br>
</br>
Functions</br>
</br>
&emsp;AbstractEvent -- properties</br>
&emsp;&emsp;DurationEvent -- duration</br>
&emsp;&emsp;&emsp;Function -- data  range  domain</br>
&emsp;&emsp;&emsp;&emsp;FourierSummation -- myForm  myArray</br>
&emsp;&emsp;&emsp;&emsp;LinearFunction</br>
&emsp;&emsp;&emsp;&emsp;&emsp;ExponentialFunction</br>
&emsp;&emsp;&emsp;&emsp;&emsp;SplineFunction -- linSeg</br>
&emsp;&emsp;&emsp;&emsp;Sound</br>
&emsp;&emsp;&emsp;&emsp;&emsp;GranularSound -- grains</br>
&emsp;&emsp;&emsp;&emsp;&emsp;StoredSound -- samplesInMemory  firstIndex  changed</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;FloatSound</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;VirtualSound -- source</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CompositeSound -- components</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GapSound -- cutList</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;WordSound</br>
</br>
Voices</br>
&emsp;Model -- dependents</br>
&emsp;&emsp;Voice -- name  instrument  stream</br>
&emsp;&emsp;&emsp;MIDIFileVoice -- fileType  tracks  ppq  tempo</br>
&emsp;&emsp;&emsp;MIDIVoice -- currentTime</br>
&emsp;&emsp;&emsp;NotelistVoice -- parameterMap</br>
&emsp;&emsp;&emsp;&emsp;CmixVoice</br>
&emsp;&emsp;&emsp;&emsp;CmusicVoice</br>
&emsp;&emsp;&emsp;&emsp;CsoundVoice</br>
&emsp;&emsp;&emsp;SoundVoice</br>
</p><hr><h3 id="Siren9CClassList">6 - Siren 9C Class List</h3></br>
Siren 9C (Cuis) Class list</br>
</br>
Category Music-Models-Representation</br>
</br>
MusicMagnitude</br>
MusicModel</br>
Chroma</br>
ModeMember</br>
Pitch</br>
Chronos</br>
Duration</br>
Meter</br>
Ergon</br>
Amplitude</br>
Positus</br>
Directionality</br>
Position</br>
Spatialization</br>
PField</br>
</br>
Category Music-Models-Implementation</br>
</br>
ConditionalDuration</br>
NominalMagnitude</br>
SymbolicLoudness</br>
SymbolicPitch</br>
NumericalMagnitude</br>
HertzPitch</br>
IntervalMagnitude</br>
MIDIPitch</br>
MIDIVelocity</br>
MeasureDuration</br>
RatioMagnitude</br>
RatioDuration</br>
RatioLoudness</br>
DBLoudness</br>
RatioPitch</br>
SecondDuration</br>
MSecondDuration</br>
USecondDuration</br>
OrdinalMagnitude</br>
Length</br>
Sharpness</br>
</br>
Category Music-Events</br>
</br>
AbstractEvent</br>
DurationEvent</br>
ActionEvent</br>
MusicEvent</br>
EventList</br>
</br>
Category Music-EventGenerators</br>
</br>
Peal</br>
EventGenerator</br>
Cloud</br>
DynamicCloud</br>
SelectionCloud</br>
DynamicSelectionCloud</br>
ExtDynamicSelectionCloud</br>
Cluster</br>
Chord</br>
Arpeggio</br>
Roll</br>
Trill</br>
Ostinato</br>
</br>
Category Music-EventModifiers</br>
</br>
EventModifier</br>
Rubato</br>
Swell</br>
</br>
Category Music-Functions</br>
</br>
FunctionEvent</br>
Function</br>
FourierSummation</br>
FunctionGraph</br>
LinearFunction</br>
ExponentialFunction</br>
SplineFunction</br>
Spectrum</br>
</br>
Category Music-PitchClasses</br>
</br>
MusicalInterval</br>
ChromaticInterval</br>
DiatonicInterval</br>
MusicalDescendingInterval</br>
OctaveDependentNote</br>
PitchClass</br>
PitchClassAltered</br>
PitchClassDoubleFlat</br>
PitchClassDoubleSharp</br>
PitchClassFlat</br>
PitchClassSharp</br>
PitchClassNatural</br>
PitchClassChord</br>
OctaveDependentChord</br>
Triad</br>
Signature</br>
</br>
Category Music-PitchScales</br>
</br>
Scale</br>
ChromaticScale</br>
DoubleHarmonic</br>
HarmonicMinorScale</br>
HungarianMinor</br>
MajorScale</br>
MelodicMinorScale</br>
NeapolitanMajor</br>
NeapolitanMinor</br>
Oriental</br>
PseudoMinorScale</br>
</br>
Category Music-Sound</br>
</br>
Sound</br>
ComponentSound</br>
SampledSound</br>
FloatSound</br>
VirtualSound</br>
CompositeSound</br>
GapSound</br>
</br>
Category Music-Support</br>
</br>
EventAssociation</br>
ScheduleRecord</br>
DeviceModel</br>
EditorModel</br>
EventScheduler</br>
PortModel</br>
SirenSession</br>
SirenUtility</br>
Timer</br>
SEventQueue</br>
</br>
Category MusicIO-Voices</br>
</br>
Voice</br>
MIDIFileVoice</br>
NotelistVoice</br>
CmixVoice</br>
CmusicVoice</br>
CsoundVoice</br>
SuperColliderVoice</br>
SoundVoice</br>
</br>
Category MusicIO-MIDI</br>
MIDIDevice</br>
MIDIFB01</br>
MIDIPF70</br>
MIDIPort</br>
PortMIDIPort</br>
MIDIVoice</br>
MIDIDump</br>
MIDIPacket</br>
</br>
Category MusicIO-OSC</br>
</br>
OSCPort</br>
OSCVoice</br>
AbstractOSCPacket</br>
OSCBundle</br>
OSCMessage</br>
TypedOSCMessage</br>
OSCByteConvertor</br>
</br>
Category MusicUI-DisplayLists</br>
</br>
DisplayItem</br>
DisplayLine</br>
DisplayRectangle</br>
DisplayPolyline</br>
DisplayList</br>
DisplayString</br>
DisplayVisual</br>
OpaqueImage</br>
</br>
Category MusicUI-DisplayListViews</br>
</br>
InnerDisplayListMorph</br>
DisplayListView</br>
DisplayListWindow</br>
DisplayListController</br>
</br>
Category MusicUI-Layout</br>
</br>
LayoutManager</br>
HierarchyLayoutManager</br>
IndentedListLayoutManager</br>
IndentedTreeLayoutManager</br>
TimeSequenceLayoutManager</br>
PitchTimeLayoutManager</br>
PositionTimeLayoutManager</br>
StructureAccessor</br>
STreeAccessor</br>
</br>
Category MusicUI-Editors</br>
</br>
EventListPanel</br>
EventListText</br>
EventListTreeEditor</br>
EventListTreeItem</br>
ScoreView</br>
TimeSequenceView</br>
PhraseView</br>
PitchTimeView</br>
HauerSteffensView</br>
PositionTimeView</br>
TimeSequenceController</br>
PitchTimeController</br>
EventListEditor</br>
EventListFileViewer</br>
</p><hr><h3 id="TheSmokeMusicRepresentation">7 - The Smoke Music Representation</h3>The Smoke Music Representation</br>
</br>
The "kernel" of Siren is in the classes related to representing the basic musical magnitudes (pitch, loudness, duration, etc.), and for creating and manipulating event and event list objects. This package is known as the Smallmusic Object Kernel (Smoke--name suggested by Danny Oppenheim).</br>
</br>
Smoke is an implementation-language-independent music representation, description language, and interchange format that was developed by a group of researchers at CCRMA/Stanford and CNMAT/Berkeley during 1990/91. </br>
</br>
The basic design requirements are that the representation support the following:</br>
&emsp;--abstract models of the basic musical quantities (scalar magnitudes such as pitch, loudness, and duration); </br>
&emsp;--flexible grain-size of "events" in terms of "notes," "grains," "elements," or "textures";</br>
&emsp;--event, control, and sampled sound processing description levels;</br>
</br>
&emsp;--nested/hierarchical event-tree structures for flexible description of "parts," "tracks," or other parallel or sequential organizations;</br>
&emsp;--annotation and marking of event tree structures supporting the creation of heterarchies (lattices) and hypermedia networks;</br>
&emsp;--annotation including common-practise notation possible;</br>
</br>
&emsp;--instrument/note (voice/event, performer/music) abstractions;</br>
&emsp;--separation of "data" from "interpretation" ("what" vs. "how" in terms of providing for interpretation objects--voices);</br>
</br>
&emsp;--abstractions for the description of "middle-level" musical structures (e.g., chords, clusters, or trills);</br>
&emsp;--sound functions, granular description, or other (non-note-oriented) description abstractions;</br>
&emsp;--description of sampled sound synthesis and processing models such as sound file mixing or DSP;</br>
</br>
&emsp;--possibility of building convertors for many common formats, such as MIDI data, Adagio, note lists, DSP code, instrument definitions, or mixing scripts; and</br>
&emsp;--possibility of parsing live performance into some rendition in the representation, and of interpreting it (in some rendition) in real-time.</br>
</br>
The "executive summary" of Smoke from (from the 1992 ICMC paper) is as follows. Music (i.e., a musical surface or structure), can be represented as a series of "events" (which generally last from tens of msec to tens of sec). Events are simply property lists or dictionaries that are defined for some duration; they can have named properties whose values are arbitrary. These properties may be music-specific objects (such as pitches or spatial positions), and models of many common musical magnitudes are provided. </br>
</br>
Events are grouped into "event lists" (AKA composite events or event collections) by their relative start times. Event lists are events themselves and can therefore be nested into trees (i.e., an event list can have another event list as one of its events); they can also map their properties onto their component events. This means that an event can be "shared" by being in more than one event list at different relative start times and with different properties mapped onto it.</br>
</br>
Events and event lists are "performed" by the action of a scheduler passing them to an interpretation object or voice. Voice objects and applications determine the interpretation of events' properties, and may assume the existence of "standard" property names such as pitch, loudness, voice, duration, or position. Voices map application-independent event properties onto the specific parameters of I/O devices or formatted files. A scheduler expands and/or maps event lists and sends their events to their voices in real time.</br>
</br>
Sampled sounds can also be described as objects, by means of synthesis "patches," or signal processing scripts involving a vocabulary of sound manipulation messages.</br>
</br>
Examples</br>
</br>
Move to the following sections for extensive examples of Smoke object creation and manipulation.</br>
</p><hr><h3 id="MusicMagnitudesandModels">8 - Music Magnitudes and Models</h3>Smoke Music Magnitude Models</br>
</br>
Smoke uses objects called music magnitudes to represent the basic "units of measure" of musical sound: duration, pitch, amplitude, etc. MusicMagnitude objects are characterized by their identity, class, species, and value (e.g., the pitch object that represents 'c3' has its object identity, the class SymbolicPitch, the species Pitch, and the value 'c3' [a string]). MusicMagnitude behaviors distinguish between class membership and species in a multiple-inheritance-like scheme that allows the object representing "440.0 Hz" to have pitch-like and limited-precision-real-number-like behaviors. This means that its behavior can depend on what it represents (a pitch), or how its value is stored (a floating-point number). </br>
</br>
The mixed-mode music magnitude arithmetic is defined using the technique of species-based coercion, i.e., class Pitch knows whether a note name or Hertz value is more general. This provides capabilities similar to those of systems that use the techniques of multiple inheritance and multiple polymorphism (such as C++ and the Common Lisp Object System), but in a much simpler and scalable manner. All meaningful coercion messages (e.g., (440.0 Hz asMIDIKeyNumber)), and mixed-mode operations (e.g., (1/4 beat + 80 msec)) are defined.</br>
</br>
The basic model classes include Pitch, Loudness, and Duration; exemplary extensions include Length, Sharpness, Weight, and Breath for composition- or notation-specific magnitudes. The handling of time as a parameter is finessed via the abstraction of duration. All times are durations of events or delays, so that no "real" or "absolute" time object is needed. Duration objects can have simple numerical or symbolic values, or they can be conditions (e.g., the duration until some event X occurs), Boolean expressions of other durations, or arbitrary blocks of Smalltalk-80 code. </br>
</br>
Functions of one or more variables are yet another type of signal-like music magnitude. The MODE Function class hierarchy includes (e.g.,) line segment, exponential segment, spline segment and Fourier summation functions. </br>
</br>
In the verbose SmOKe format music magnitudes, events and event lists are created by instance creation messages sent to the appropriate classes. The first three expressions in the examples below create various music magnitudes and coerce them into other representations. </br>
</br>
The terse form for music magnitude creation uses post-operators (unary messages) such as 440 hz or 250 msec, as shown in the examples below.</br>
</br>
Users can extend the music magnitude framework with their own classes that refine the existing models of define totally new kinds of musical metrics.</br>
</br>
Basic MusicMagnitude Models</br>
&emsp;</br>
Durations</br>
&emsp;SecondDuration -- 1 sec</br>
&emsp;MSecondDuration -- 100 msec (milliseconds)</br>
&emsp;USecondDuration -- 100000 usec (microseconds)</br>
&emsp;RatioDuration -- 1/4 beat (relative fractions of some tempo scale)</br>
&emsp;ConditionalDuration -- until: [ :t | boolean-block]</br>
</br>
Pitches</br>
&emsp;HertzPitch -- 440.0 hz</br>
&emsp;MIDIPitch -- 60 pitch -- (or 60 key) can be non-integer for microtonal tunings (use #asFracMIDI)</br>
&emsp;SymbolicPitch -- 'c#3' pitch -- several different pitch spellings supported</br>
&emsp;RatioPitch -- 11/9 of: anotherPitch -- used for fraction-oriented tunings</br>
</br>
Amplitude/Loudness Objects</br>
&emsp;DBLoudness -- -3 dB -- can be negative relative to 0 dB or positive-valued</br>
&emsp;RatioLoudness -- 0.7071 ampl (or 0.7071 loudness) -- range of 0.0 to 1.0</br>
&emsp;SymbolicLoudness -- 'fff' ampl</br>
&emsp;MIDIVelocity -- 96 velocity</br>
</br>
Other Music Magnitudes</br>
&emsp;OrdinalMagnitudes -- have order but no explicit value</br>
&emsp;PField -- name/slot/value -- used for note lists</br>
&emsp;See also magnitude accessors in LayoutManagers</br>
</br>
MusicMagnitude Examples</br>
</br>
Verbose MusicMagnitude Creation and Coercion Messages</br>
</br>
&emsp;(Duration value: 1/16) asMsec&emsp;&emsp;&emsp;"Answers Duration 62 msec." </br>
&emsp;(Pitch value: 60) asHertz &emsp;&emsp;&emsp;&emsp;"Answers Pitch 261.623 Hz." </br>
&emsp;(Amplitude value: 'ff') asMIDI&emsp;&emsp;&emsp;"Answers MIDI key velocity 100." </br>
</br>
Terse MusicMagnitude Creation using post-operators</br>
</br>
&emsp;440 Hz&emsp;&emsp;&emsp;&emsp;&emsp;"a HertzPitch"</br>
&emsp;'c#3' pitch&emsp;&emsp;&emsp;&emsp;&emsp;"a SymbolicPitch"</br>
&emsp;'cs3' pitch&emsp;&emsp;&emsp;&emsp;&emsp;"a SymbolicPitch"</br>
&emsp;60 pitch&emsp;&emsp;&emsp;&emsp;&emsp;"a MIDIPtch"</br>
&emsp;60 key&emsp;&emsp;&emsp;&emsp;&emsp;"a MIDIPtch"</br>
&emsp;250 msec&emsp;&emsp;&emsp;&emsp;&emsp;"a MSecondDuration"</br>
&emsp;1/4 beat&emsp;&emsp;&emsp;&emsp;&emsp;"a RatioDuration"</br>
&emsp;-16 dB&emsp;&emsp;&emsp;&emsp;&emsp;"a DBLoudness"</br>
&emsp;'fff' ampl&emsp;&emsp;&emsp;&emsp;&emsp;"a SymbolicLoudness"</br>
&emsp;0.1 ampl&emsp;&emsp;&emsp;&emsp;&emsp;"a RatioLoudness"</br>
</br>
MusicMagnitude Coercion Examples</br>
</br>
&emsp;440 Hz asSymbol&emsp;&emsp;&emsp;"--> 'a3' pitch"</br>
&emsp;(1/4 beat) asMsec&emsp;&emsp;&emsp;"--> 250 msec"</br>
&emsp;#mf ampl asMIDI&emsp;&emsp;&emsp;"--> 70 vel"</br>
&emsp;-16 dB asRatio value&emsp; &emsp;&emsp;"--> 0.158489"</br>
&emsp;0.1 ampl asMIDI&emsp;&emsp;&emsp;"--> 12 vel"</br>
</br>
Duration Coercion Example--create a 1/8 beat duration and coerce it into a couple of other representations, printing the result to the Smalltalk transcript. To execute this, double-click just inside the open-bracket to select the entire expression and use the pop-up menu or command key (control-d) to "do it."</br>
</br>
&emsp;[ | me |</br>
&emsp;me := Siren.Duration value: 1/8.</br>
&emsp;Transcript cr; show: me printString, ' = ',</br>
&emsp;&emsp;me asSec printString, ' = ',</br>
&emsp;&emsp;me asUsec printString; cr] d</br>
</br>
Pitch Coercion Example--create a named pitch (middle C) and print it to the transcript as Hz and as a MIDI key number.</br>
</br>
&emsp;[ | me |</br>
&emsp;me := Pitch value: 'c3'.</br>
&emsp;Transcript show: me printString, ' = ',</br>
&emsp;&emsp;me asHertz printString, ' = ',</br>
&emsp;&emsp;me asMIDI printString; cr.</br>
&emsp;"me inspect"] d</br>
</br>
Amplitude Coercion Example--create a named dynamic value and print it as an amplitude ratio and a MIDI velocity.</br>
</br>
&emsp;[ | me |</br>
&emsp;me := Amplitude value: #mf.</br>
&emsp;Transcript show: me printString, ' = ',</br>
&emsp;&emsp;me asRatio printString, ' = ',</br>
&emsp;&emsp;me asDB printString, ' = ',</br>
&emsp;&emsp;me asMIDI printString; cr.</br>
&emsp;"me inspect"] d</br>
</br>
Mixed-mode Arithmetic--demonstrate adding beats and msec, or note names and Hertz values. Select and print these.</br>
</br>
&emsp;[(1/2 beat) + 100 msec]&emsp;&emsp;&emsp;" (0.6 beat")</br>
&emsp;['a4' pitch + 25 Hz]&emsp;&emsp;&emsp;&emsp;&emsp;" (465.0 Hz)"</br>
&emsp;[('a4' pitch + 100 Hz) asMIDI]&emsp;&emsp;" (73 key)"</br>
&emsp;[('a4' pitch + 100 Hz) asFracMIDI]&emsp;" (72.5455 key)"</br>
&emsp;['mp' ampl + 3 dB]&emsp;&emsp;&emsp;&emsp;&emsp;" (-4.6 dB)"</br>
</br>
Microtonality</br>
</br>
Alberto de Campo's microtonal extensions allow MIDI pitches to be floating-point numbers (e.g., MIDI key 60.25) and named pitches to have "remainder" values (e.g., c3 + 25 cents) as in the following examples.</br>
</br>
&emsp;[438 Hz asSymbol] &emsp; &emsp;"rounds to nearest chromatic note, a3."</br>
&emsp;[443.5 Hz asMIDI]&emsp;&emsp;&emsp;"ditto."</br>
&emsp;[265 Hz asFracMIDI]&emsp;&emsp;"converts to float chromatics; can be rounded, used</br>
 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;for MIDI pitch bend or for precise synthesis in Hz."</br>
&emsp;[61.26 key asHertz]&emsp;&emsp;"float chromatics can also be used directly; for</br>
 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;microtonal scales this is clearer than Hz (to me at least)."</br>
&emsp;[260.0 Hz asFracSymbol] &emsp;"is rounded, but keeps track of offsets in</br>
  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;an inst var (fracPitch); survives conversions etc."</br>
</br>
Note that asMIDI and asSymbol can now be used to round pitches to chromatics, while the messages asFracMIDI and asFracSymbol keep the full microtonal precision.</br>
</br>
Conditional Durations</br>
</br>
Conditional durations allow one to have state-dependent events lists.</br>
</br>
&emsp;[ConditionalDuration exampleWithRands]</br>
&emsp;[ConditionalDuration until: [ :x | x > 5]]</br>
</br>
Extending Siren's MusicMagnitude Models</br>
</br>
Developers and composers can extend the core Smoke representation by adding new magnitude models (abstract species classes with instance creation methods, post-fix operators and a generality table) and concrete magnitudes (with units, coercion methods, and print/store). This is relatively easy and can be very useful for a composition that uses a new model for its structure.</br>
</p><hr><h3 id="PitchClassesandScales">9 - Pitch Classes and Scales</h3>MusES Pitch Classes, Intervals, Scales, and Chords</br>
</br>
Siren incorporates Francois Pachet et al's MusES pitch class package (see http://www-poleia.lip6.fr/~fdp/MusES.html). A pitch class is an abstraction of a single pitch or note name (e.g., C in any octave, or 'fa' in any key), and there are relationships for pitch class spelling (f#, la flat), pitch equivalence, enharmonic equivalence (do sharp = re flat), and interval algebra.</br>
</br>
Based on this, chords and scales can be defined according to pitch class rules.</br>
</br>
To make the code easy to use, MusES puts a shortcut in the Smalltalk global dictionary; the global variable N holds the PitchClass class, making the following code examples easier to read.</br>
</br>
Print these to see results, or look at the advanced EventGenerator examples.</br>
</br>
Pitch expressions (print these)</br>
&emsp;[N C sharp sharp]</br>
&emsp;[N C augmentedFourth]</br>
&emsp;[N C diminishedThirteenth]</br>
&emsp;[N C augmentedFourth pitchEqual: N C diminishedFifth]</br>
&emsp;[N D sharp closestEnharmonic]</br>
&emsp;[N E flat closestEnharmonic] </br>
</br>
Intervals</br>
&emsp;[N do flat intervalBetween: N sol]</br>
&emsp;[MusicalInterval perfectFourth topIfBottomIs: N F sharp]</br>
&emsp;[MusicalInterval allIntervalsType: 4]</br>
</br>
Scales</br>
&emsp;[PitchClass B majorScale notes]</br>
&emsp;[PitchClass D flat melodicMinorScale notes]</br>
</br>
To use a scale as real pitches, you need to give it an octave, as in</br>
&emsp;[PitchClass C majorScale asPitchesInOctave: 5]</br>
&emsp;[(HungarianMinor root: N fa) asPitchesInOctave: 2] </br>
</br>
Chords</br>
&emsp;(PitchClassChord new fromString: 'C') notes</br>
&emsp;(PitchClassChord new fromString: 'Re maj7') notes</br>
&emsp;(PitchClassChord new fromString: 'C 13 aug9') notes</br>
&emsp;(PitchClassChord new fromString: 'C aug9 dim5') notes</br>
</br>
Key signatures</br>
&emsp;[Signature choseSignature]</br>
&emsp;[(Signature new nbSharps: 4) tonality]</br>
&emsp;[Signature fromTonality: N E flat majorScale]</br>
</br>
EventList Examples using Scales</br>
</br>
&emsp;[((NeapolitanMinor root: N do) generateChordsPoly: 5 inOctave: 3) scrambled] p</br>
</br>
Extending the Models of Pitch Classes and Scales</br>
</br>
Obviously, this framework is designed for ease of extension, and new interval types, scale rules, families of key signatures are all straightforward to add.</br>
</br>
[(BohlenPierceScale root: N mi) inspect]</br>
</p><hr><h3 id="SmokeEventsandProperties">10 - Smoke Events and Properties</h3>Smoke Events</br>
</br>
All musical structures in Smoke--from micro-sound components of a note, to entire compositions--are represented as event objects. Events are very simple objects that have lists of properties, and get/set methods for managing these properties. The Event object in Smoke is modeled as a property-list dictionary with a duration. Events have no notion of external time until their durations become active. Event behaviors include duration and property accessing, and "performance," where the semantics of the operation depends on another object--a voice or driver as described below. </br>
</br>
The event classes are quite simple; events have little interesting behavior (most of that being taken over by event lists and voices), and there is not a rich hierarchy of kinds of events.</br>
</br>
The primary messages that events understand are property getter/setters,</br>
&emsp;(anEvent duration: someDurationObject)</br>
to set the duration time of the event to some Duration-type music magnitude, and property accessing messages such as </br>
&emsp;(anEvent color: #blue)</br>
to set the "color" (an arbitrary property) to an arbitrary value (the symbol #blue). </br>
</br>
The meaning of an event's properties is interpreted by voices and user interface objects; it is obvious that (e.g.,) a pitch could be mapped differently by a MIDI output voice and a graphical notation editor. It is common to have events with complex objects as properties (e.g., envelope functions, real-time controller maps, DSP scripts, structural annotation, version history, or compositional algorithms), or with more than one copy of some properties (e.g., one event with enharmonic pitch name, key number, and frequency, each of which may be interpreted differently by various voices or structure accessors). The distinction between a complex event object model and adaptors and visitors with dynamic state is intentionally blurred.</br>
</br>
That there is no prescribed "level" or "grain size" for events in Smoke. There may be a one-to-one or many-to-one relationship between events and "notes," or single event objects may be used to represent long complex textures or surfaces.</br>
</br>
Note the way that Smoke uses the Smalltalk concatenation message "," (comma) to denote the construction of events and event lists; (magnitude, magnitude) means to build an event with the two magnitudes as properties, and (event, event) or ((duration -> event) , (duration -> event)) means to build an event list with the given events as components.</br>
</br>
There are classes for events are as follows.</br>
&emsp;AbstractEvent -- just a property list</br>
&emsp;DurationEvent -- adds duration and scheduling behavior</br>
&emsp;MusicEvent -- adds pitch, loudness and voice</br>
&emsp;ActionEvent -- has a block that it evaluates when scheduled</br>
</br>
It is seldom necessary to extend the hierarchy of events.</br>
</br>
Event Creation Examples</br>
</br>
Verbose Event Creation Messages -- Class messages</br>
&emsp;</br>
"Create a `generic' event."</br>
&emsp;MusicEvent duration: 1/4 pitch: 'c3' ampl: 'mf'</br>
</br>
"Create one with added properties."</br>
&emsp;(MusicEvent dur: 1/4 pitch: 'c3') color: #green; accent: #sfz</br>
</br>
Terse Event Creation using concatenation of music magnitudes--inspect these.</br>
</br>
&emsp;[440 Hz, (1/4 beat), 44 dB]</br>
</br>
&emsp;[490 Hz, (1/7 beat), 56 dB, (#voice -> #flute), (#embrochure -> #tight)]</br>
</br>
&emsp;[(#c4 pitch, 0.21 sec, 64 velocity) voice: MIDIVoice default]</br>
</p><hr><h3 id="EventListsandStructureinSmoke">11 - EventLists and Structure in Smoke</h3>Smoke Event Lists</br>
</br>
In accordance to the "composite" OO design pattern, EventList objects hold onto collections of events that are tagged and sorted by their start times (represented as the duration between the start time of the container event list and that of the constituent event). The event list classes are subclasses of Event themselves. This means that event lists can behave like events and can therefore be arbitrarily deeply nested, i.e., one event list can contain another as one of its events. </br>
</br>
The primary messages to which event lists respond (in addition to the behavior they inherit by being events), are</br>
&emsp;(anEventList add: anEvent at: aDuration) -- to add an event to the list</br>
&emsp;(anEventList play) -- to play the event list on its voice (or a default one)</br>
&emsp;(anEventList edit) -- to open a graphical editor in the event list</br>
&emsp;(anEventList open) -- either edit, play or inspect, depending on the <SHIFT> and <CTRL> keys</br>
and Smalltalk-80 collection iteration and enumeration messages such as </br>
&emsp;(anEventList do: [1-arg-block]) -- to iterate over a list's events</br>
&emsp;(anEventList select: [Bool-Block]) -- to select the events that satisfy the given (Boolean) function block. </br>
</br>
Event lists can map their own properties onto their events in several ways. Properties can be defined as lazy or eager, to signify whether they map themselves when created (eagerly) or when the event list is performed (lazily). This makes it easy to create several event lists that have copies of the same events and map their own properties onto the events at performance time under interactive control. Voices handle mapping of event list properties via event modifiers, as described below.</br>
</br>
In a typical hierarchical Smoke score, data structure composition is used to manage the large number of events, event generators and event modifiers necessary to describe a full performance. The score is a tree--possibly a forest (i.e., with multiple roots) or a lattice (i.e., with cross-branch links between the inner nodes)--of hierarchical event lists representing sections, parts, tracks, phrases, chords, or whatever abstractions the user desires to define. Smoke does not define any fixed event list subclasses for these types; they are all various compositions of parallel or sequential event lists.</br>
</br>
Note that events do not know their start times; this is always relative to some outer scope. This means that events can be shared among many event lists, the extreme case being an entire composition where one event is shared and mapped by many different event lists (as described in [Scaletti 1989]). The fact that the Smoke text-based event and event list description format consists of executable Smalltalk-80 message expressions (see examples below), means that it can be seen as either a declarative or a procedural description language. The goal is to provide "something of a cross between a music notation and a programming language" (Dannenberg 1989). </br>
</br>
Event List Examples</br>
</br>
The verbose way of creating an event list is to create a named instance and add events explicitly as shown in the first example below, which creates a D-major chord.</br>
</br>
&emsp;[((EventList newNamed: #Chord1)</br>
&emsp;&emsp;add: (1/2  beat, 'd3'  pitch,  'mf' ampl)  at: 0;</br>
&emsp;&emsp;add: (1/2  beat, 'fs3'  pitch, 'mf' ampl)  at: 0;</br>
&emsp;&emsp;add: (1/2  beat, 'a4'   pitch, 'mf' ampl)  at: 0) open]</br>
</br>
This same chord could be defined more tersely as a dictionary of (duration => event) pairs,</br>
</br>
&emsp;[((0 => (1/2 beat, 'd3' pitch, 'mf' ampl)), </br>
&emsp;  (0 => (1/2 beat, 'fs3' pitch, 'mf' ampl)), </br>
&emsp;  (0 => (1/2 beat, 'a4' pitch, 'mf' ampl))) open]</br>
</br>
Note the use of the "=>" message, which works just like Smalltalk's "->'" in that it creates an association between the key on the left and the value on the right; the difference is that it creates a special kind of association called an EventAssociation.</br>
</br>
This could be done even more compactly using a Chord object (see the discussion of event generators below) as,</br>
</br>
&emsp;[(Chord majorTriadOn: 'd3' inversion: 0) eventList open]</br>
</br>
Terse EventList creation using concatenation of events or (duration, event) asociations looks like,</br>
</br>
&emsp;[(440 Hz, (1/2 beat), 44.7 dB),&emsp;&emsp;"note the comma between events"</br>
&emsp; (1 => ((1.396 sec, 0.714 ampl) phoneme: #xu))]&emsp;"2nd event starts at 1 second"</br>
</br>
Bach Example--First measure of Fugue 2 from the Well-Tempered Klavier (ignoring the initial rest).</br>
</br>
&emsp;&emsp;((0 beat) => (1/16 beat,  'c3' pitch)),</br>
&emsp;&emsp;((1/16 beat) => (1/16 beat, 'b2'  pitch)),</br>
&emsp;&emsp;((1/8 beat)  => (1/8 beat,  'c3' pitch)),</br>
&emsp;&emsp;((1/4 beat) => (1/8 beat, 'g2'  pitch)),</br>
&emsp;&emsp;((3/8 beat) => (1/8 beat, 'a-flat2'  pitch)),</br>
&emsp;&emsp;((1/2 beat) => (1/16 beat,  'c3' pitch)),</br>
&emsp;&emsp;((1/16 beat) => (1/16 beat, 'b2'  pitch)),</br>
&emsp;&emsp;((1/8 beat)  => (1/8 beat,  'c3' pitch)),</br>
&emsp;&emsp;((3/4 beat) => (1/8 beat, 'd3'  pitch)),</br>
&emsp;&emsp;((7/8 beat) => (1/8 beat, 'g2'  pitch))</br>
</br>
There are more comfortable event list creation methods, such as the following examples.</br>
</br>
Play a chromatic scale giving the initial and final pitches (as MIDI key numbers) and total duration (in seconds)</br>
</br>
&emsp;[(EventList scaleFrom: 48 to: 60 in: 1.5) open] d</br>
</br>
Create 64 random events with parameters in the given ranges and play them over the default output voice.</br>
</br>
&emsp;[(EventList randomExample: 32 </br>
&emsp;&emsp;from: ((#duration: -> (50 to: 200)),&emsp;&emsp;"durations in msec"</br>
&emsp;&emsp;&emsp;&emsp;(#pitch: -> (36 to: 60)),&emsp;&emsp;&emsp;"pitchs as MIDI key numbers"</br>
&emsp;&emsp;&emsp;&emsp;(#ampl: -> (48 to: 120)),&emsp;&emsp;"amplitudes as MIDI key velocities"</br>
&emsp;&emsp;&emsp;&emsp;(#voice: -> (1 to: 1)))) open]&emsp;"voices as numbers"</br>
</br>
Note that the argument for the keyword "from:" is a dictionary in the form (property-name -> value-interval).</br>
</br>
Same with named instruments = play using named instruments</br>
</br>
&emsp;[(EventList randomExample: 64 </br>
&emsp;&emsp;from: ((#duration: -> (0.15 to: 0.4)),&emsp;&emsp;&emsp;"dur in sec"</br>
&emsp;&emsp;&emsp;&emsp;(#pitch: -> (36 to: 60)),&emsp;&emsp;&emsp;&emsp;&emsp;"MIDI pitch"</br>
&emsp;&emsp;&emsp;&emsp;(#ampl: -> (48 to: 120)),&emsp;&emsp;&emsp;&emsp;"MIDI velocity"</br>
&emsp;&emsp;&emsp;&emsp;(#voice: -> #(organ1 flute2 clarinet bassoon1 marimba bass1)))) open]</br>
</br>
Event lists don't have to have pitches at all, as in the word,</br>
</br>
&emsp;[EventList named: 'phrase1'  </br>
&emsp;&emsp;fromSelectors: #(duration: loudness: phoneme:)&emsp;&emsp;&emsp;"3 parameters"</br>
&emsp;&emsp;values: (Array with: #(595 545 545 540 570 800 540) &emsp;"3 value arrays"</br>
&emsp;&emsp;&emsp;&emsp;&emsp;with: #(0.8 0.4 0.5 0.3 0.2 0.7 0.1) </br>
&emsp;&emsp;&emsp;&emsp;&emsp;with: #(#dun #kel #kam #mer #ge #sprae #che)).</br>
&emsp;(EventList named: 'phrase1') inspect]</br>
</br>
Note the format of the arguments to the message "fromSelectors: values:" used above, the first is an array of property selector symbols, and the second is an array of arrays for the property data</br>
</br>
There are a number of useful EventList instance creation methods based on the "fromSelectors: values:" method, for example, the following example shows the use of data lists in a serial style for score creation.</br>
</br>
&emsp;[(EventList serialExample: 64 </br>
&emsp;&emsp;from: ((#duration: -> #(0.1 0.1 0.1 0.2)), (#pitch: -> #(48 50 52 53 52)),</br>
&emsp;&emsp;&emsp;&emsp;(#ampl: -> #(48 64)), (#voice: -> #(1)))) open] </br>
</br>
This example creates a scale where the event property types (duration, pitch, amplitude) are mixed.</br>
</br>
&emsp;[EventList scaleExample2] i</br>
</br>
Here's another example of creating a simple melody</br>
</br>
&emsp;[(EventList named: 'melody'  </br>
&emsp;&emsp;fromSelectors: #(pitch: duration:)</br>
&emsp;&emsp;values: (Array with: #(c d e f g) </br>
&emsp;&emsp;&emsp;&emsp;&emsp;with: #(4 8 8 4 4) reciprocal)) open]</br>
</br>
You can create event lists with snippets of code such as the following whole-tone scale.</br>
</br>
&emsp;[ | elist |</br>
&emsp;elist := EventList newAnonymous.</br>
&emsp;1 to: 12 do:</br>
&emsp;&emsp;[ :index |</br>
&emsp;&emsp;elist add: (1/4  beat, (index * 2 + 36) key,  #mf ampl)].</br>
&emsp;elist open ]</br>
</br>
Event lists can be nested into arbitrary structures, as in the following group of four sub-groups</br>
</br>
&emsp;[(EventList newNamed: 'Hierarchical/4Groups')</br>
&emsp;&emsp;add: (EventList randomExample: 8 </br>
&emsp;&emsp;&emsp;from: ((#duration: -> (60 to: 120)), (#pitch: -> (36 to: 40)), (#ampl: -> #(110)))) at: 0;</br>
&emsp;&emsp;add: (EventList randomExample: 8 </br>
&emsp;&emsp;&emsp;from: ((#duration: -> (60 to: 120)), (#pitch: -> (40 to: 44)), (#ampl: -> #(100)))) at: 1;</br>
&emsp;&emsp;add: (EventList randomExample: 8 </br>
&emsp;&emsp;&emsp;from: ((#duration: -> (60 to: 120)), (#pitch: -> (44 to: 48)), (#ampl: -> #(80)))) at: 2;</br>
&emsp;&emsp;add: (EventList randomExample: 8</br>
&emsp;&emsp;&emsp;from: ((#duration: -> (60 to: 120)), (#pitch: -> (48 to: 52)), (#ampl: -> #(70)))) at: 3;</br>
&emsp;&emsp;open "inspect" ]</br>
</br>
Smalltalk methods can process event lists in many different ways, as in this code that uses the eventsDo: [] message to increase the durations of the last notes in each of the subgroups from the previous example.</br>
</br>
&emsp;[(EventList named: 'Hierarchical/4Groups') eventsDo: </br>
&emsp;&emsp;[ :sublist | | evnt |&emsp;&emsp;&emsp;"Remember: this is hierarchical, to the events are the sub-groups"</br>
&emsp;&emsp;evnt := sublist events last event.&emsp;&emsp;"get the first note of each group"</br>
&emsp;&emsp;evnt duration: evnt duration * 4].&emsp;&emsp;"multiply the duration by 4"</br>
&emsp;(EventList named: #groups) open ]</br>
</br>
In the following example, we iterate over a scale and make it slow down to changing the event start times</br>
</br>
&emsp;[ | elist |</br>
&emsp;elist := EventList scaleExampleFrom: 60 to: 36 in: 3. </br>
&emsp;1 to: elist size do: </br>
&emsp;&emsp;[ :index | | assoc |</br>
&emsp;&emsp;assoc := elist events at: index.</br>
&emsp;&emsp;assoc key: (assoc key * (1 + (index / elist events size)))].</br>
&emsp;elist open ]</br>
</br>
There are many more event list processing examples in the various class example methods, and in the event generator example that follow in this workbook.</br>
</br>
Storage and Utilities</br>
</br>
Note the use of event list names in the above examples. All named event lists are stored in a hierarchical dictionary named EventLists that's held in class SirenSession. To look at all named event lists, execute the following</br>
&emsp;[SirenSession eventLists] i</br>
</br>
If you create an event list with a name that contains the character '/', then it is assumed to be in a subdictionary of the top-level event list dictionary, as in the example above that created an event list named 'Hierarchical/4Groups.' You can use this to manage your own sketches and pieces. If you create an event list named 'Opus1/Prelude/Exposition/Theme1' then the hierarchy of implicit in the name will be reflected by an automatically created hierarchical set of event list dictionaries.</br>
&emsp;"SirenSession eventList: 'piece1/mvmnt1/part1' put: EventList new"</br>
&emsp;"SirenSession eventList: 'piece1/mvmnt1/part1'"</br>
</br>
There's a pop-up menu in the transport view that allows you to select event lists from this hierarchy.</br>
</br>
You can erase the temporary lists (those in the dictionary named #Temp) from the EventList dictionary with,</br>
&emsp;[SirenSession flushTempEventLists]</br>
</br>
or to flush all,</br>
&emsp;[SirenSession flushAllEventLists]</br>
</br>
Inspect a dictionary of all known event lists.</br>
&emsp;[SirenSession eventLists inspect]</br>
</br>
To read in a stored file, simply,</br>
&emsp;[(Filename named: 'events.st') fileIn]</br>
</br>
Load all event lists (.ev, .midi, and .gio files), from the data directories.</br>
&emsp;[SirenSession loadDemoData]</br>
</br>
Extending The Event/EventList Framework</br>
</br>
There are a number of approaches one can take to extend the Smoke framework. The core event classes rarely need extension of subclassing. Simple methods in a workspace or class example methods can create and process event lists through many stages, and the built-in persistency and versioning in s7 files aids composers in the stages of content creation, refinement, sorting, and mixing. </br>
</br>
It is often useful to add new EventList instance creation method for short-hand representations of chords, scales, etc. One can also write new processing methods (e.g., filters) in the EventList class. These can also be placed on EventGenerator or EventModifier classes (see the next workbook sections).</br>
</p><hr><h3 id="ControlFunctionsandtheirApplication">12 - Control Functions and their Application</h3>Siren Functions</br>
</br>
There are several classes that represent functions of 1 variable (typ. time) such as envelopes or waveforms. These objects can be described using (e.g.,) linear or exponential interpolation between n-dimensional break-points, Fourier sine summation, cubic splines, or as raw sampled data. In addition to the instance creation methods, Functions understand array-like accessing method at: or atX: to get at their values.</br>
</br>
The FunctionView displays up to 4 functions and supports simple editing.</br>
</br>
Function Creation Examples</br>
</br>
The expressions below demonstrate the various creation techniques for Siren functions.</br>
</br>
If you like thicker function plots, do this,</br>
&emsp;[FunctionView lineWidth: 2]</br>
</br>
Basic ramp up/down (linear and exponential flavors)</br>
&emsp;[(LinearFunction from: #((0 0) (0.5 1) (1 0))) at: 0.25] p</br>
&emsp;[(ExponentialFunction from: #((0 0 5) (0.5 1 -5) (1 0))) at: 0.25 ] p</br>
</br>
ADSR-like envelopes</br>
&emsp;[(LinearFunction from: #((0 0) (0.1 1) (0.16 0.7) (0.8 0.4) (1 0))) edit]</br>
&emsp;[(ExponentialFunction from: #((0 0 5) (0.1 1 -3) (0.8 0.4 -2) (1 0))) edit]</br>
</br>
Open a view with a linear envelope, an exponential envelope, a spline curve, and a sum-of-sines function</br>
&emsp;[FunctionView multiFunctionExample]</br>
</br>
Sine Summation</br>
&emsp;[(FourierSummation from: #((1 1 0)  (3 0.3 0)  (5 0.2 0)  (7 0.15 0)  (9 0.11 0)  (11 0.09 0))) edit]</br>
</br>
Others</br>
&emsp;[(Function randomOfSize: 512 from: 0.2 to: 0.9) edit]</br>
&emsp;[FunctionView onFunction: </br>
&emsp;&emsp;(Function from: #( 0 1 0 0.5 1.0 0.5 0 1 0 0.3 0.6 0.9 1 0.5 0.25 0.125 0.0625 0 1 0))]</br>
</br>
Using Functions</br>
</br>
One can apply a function to any property of an event list, as in the example below, which makes a crescendo/decrescendo using an exponential triangle function.</br>
</br>
&emsp;[ | list fcn |</br>
&emsp;list := EventList newNamed: #test3.</br>
&emsp;(0 to: 4000 by: 100) do: &emsp;"4 seconds, 10 notes per second"</br>
&emsp;&emsp;&emsp;[ :index |&emsp;&emsp;&emsp;"add the same note"</br>
&emsp;&emsp;&emsp;list add: (MusicEvent dur: 100 pitch: 36 ampl: 120) at: index].</br>
&emsp;fcn := ExponentialFunction from: #((0 0.05 2) (0.5 1 -2) (1 0.05)).</br>
&emsp;list applyFunction: fcn to: #loudness.</br>
&emsp;list inspect] d</br>
</br>
The next examples show how functions can be queried; the first expression displays a function that has large changes in its slope; the expressions after that illustrate that one can ask a function for an X value where it crosses a threshold of difference from some other X value, e.g., the 2nd expression below means "find the first value after X = 0.1 where the value is more than 0.01 different from the value at X = 0.1." This is quite useful in data reduction and in output scheduling (i.e., don't keep sending the same controller value)</br>
</br>
Create a function with a large change in slope.</br>
&emsp;[(LinearFunction from: #((0 0.2) (0.6 0.3) (0.62 1.0) (1.0 0.3))) edit] d</br>
Query the delta threshold in the low-slope section</br>
&emsp;[(LinearFunction from: #((0 0.2) (0.6 0.3) (0.62 1.0) (1.0 0.3))) </br>
&emsp;&emsp;&emsp;nextXMoreThan: 0.01 from: 0.1] p</br>
Query the delta threshold in the high-slope section</br>
&emsp;[(LinearFunction from: #((0 0.2) (0.6 0.3) (0.62 1.0) (1.0 0.3))) </br>
&emsp;&emsp;&emsp;nextXMoreThan: 0.1 from: 0.6] p</br>
</br>
Functions support standard arithmetic, so that one can scale them by numbers, or add/multiply functions as though they were numbers, as illustrated by the examples below.</br>
</br>
&emsp;[((FourierSummation from: #((5 0.1 0))) + 0.6) open]</br>
</br>
&emsp;[ | sin tri |</br>
&emsp;tri := LinearFunction from: #((0 0) (0.5 0.9) (1 0)).</br>
&emsp;sin := FourierSummation from: #((17 0.05 0)).</br>
&emsp;rnd := Function randomOfSize: 512 from: 0.0 to: 1.0.</br>
&emsp;FunctionView lineWidth: 2.&emsp;&emsp;&emsp;"set a bold line width"</br>
&emsp;FunctionView onFunctions: </br>
&emsp;&emsp;(Array </br>
&emsp;&emsp;&emsp;with: (tri + sin) &emsp;&emsp;&emsp;&emsp;&emsp;"triangle + sine"</br>
&emsp;&emsp;&emsp;with: (tri * sin + 0.2) &emsp;&emsp;&emsp;"triangle * sine + offset"</br>
&emsp;&emsp;&emsp;with: (rnd * 0.1 + 0.5) &emsp;&emsp;&emsp;"noise with scale/offset"</br>
&emsp;&emsp;&emsp;with: (tri * 0.25))&emsp;&emsp;&emsp;&emsp;"triangle scaled by constant"</br>
&emsp;&emsp;withColors: (Array with: ColorValue blue with: ColorValue red</br>
&emsp;&emsp;&emsp;&emsp;with: ColorValue cyan with: ColorValue green)</br>
&emsp;&emsp;normalize: #(false false false false)</br>
&emsp;&emsp;x: 512 y: 256] d</br>
</br>
Function Views</br>
</br>
The following multi-linear-function view example creates 4 linear functions and displays them</br>
</br>
&emsp;[FunctionView lineWidth: 2.&emsp;&emsp;&emsp;"set a bold line width"</br>
&emsp;FunctionView onFunctions: (Array </br>
&emsp;&emsp;&emsp;with: (LinearFunction from: #((0@0) (0.15@1.0) (0.25@0.75) (0.75@0.5) (1@0))) </br>
&emsp;&emsp;&emsp;with: (LinearFunction from: #((0@0.1) (0.3@0.7) (0.7@0.45) (1@0))) </br>
&emsp;&emsp;&emsp;with: (LinearFunction from: #((0@0) (0.05@1) (0.2@0.35) (1@0))) </br>
&emsp;&emsp;&emsp;with: (LinearFunction from: #((0@0.2) (0.6@0.3) (1@0.3))))</br>
&emsp;&emsp;withColors: (Array with: ColorValue blue with: ColorValue red</br>
&emsp;&emsp;&emsp;&emsp;with: ColorValue cyan with: ColorValue green)</br>
&emsp;&emsp;normalize: #(false false false false)</br>
&emsp;&emsp;x: 512 y: 256] d</br>
</br>
The next example mixes the types of function as well as the normalization switches</br>
</br>
&emsp;[FunctionView </br>
&emsp;&emsp;onFunctions: (Array with: (LinearFunction from: #((0 0) (0.12 1) (0.17 0.74) </br>
&emsp;&emsp;&emsp;&emsp;(0.35 0.5) (0.9 0.4) (1 0) )) </br>
&emsp;&emsp;&emsp;with: (FourierSummation from: #((1 0.5 0)  (3 0.15 0)  (5 0.1 0)  (7 0.075 0)  (9 0.055 0)  (11 0.05 0)))</br>
&emsp;&emsp;&emsp;with: (ExponentialFunction from: #((0 0 5) (0.05 1 -5) (0.2 0.25 -1) (1 0))) </br>
&emsp;&emsp;&emsp;with: (SplineFunction from: #((0 0.5) (0.3 0.6) (0.7 0.5) (0.85 0.7) (1 0.6))))</br>
&emsp;&emsp;&emsp;withColors: FunctionView defaultColors</br>
&emsp;&emsp;normalize: #(false true false false) </br>
&emsp;x: 512 y: 256] d</br>
</br>
Playing functions as controllers</br>
</br>
Several of the voice classes (see below) can use Siren functions to send out sampled continuous control messages. The class FunctionEvent provides the methods needed to package functions in event lists, and allows you to specify a fixed update rate or a value change threshold for output scheduling. The following example sends out OSC frequency updates at the rate of 4 Hz to the address /osc/1/ampl with values taken from a linear envelope. Start an OSC dump utility before executing this.</br>
</br>
&emsp;[OSCVoice functionExample] d</br>
</br>
Similarly, one can use functions as MIDI controller messages, as in this example, which uses a linear function to create a swell on an organ note.</br>
&emsp;[MIDIPort functionExample] d</br>
</br>
Spectra and Signal Analysis</br>
</br>
A spectrum is simply another kind of function (with real or complex values), and Siren supports the fast Fourier transform for spectral analysis and resynthesis via the FFTW lbrary. There is also a simple spectral display, as illustrated by the examples below.</br>
</br>
Create a swept sine wave and take its fft.</br>
&emsp;[Spectrum sweepExample display]</br>
</br>
Read a file (T'ang dynasty speech) and show the spectrogram</br>
&emsp;[Spectrum fileExample display] db</br>
</br>
Loading SHARC (Sandell Harmonic ARChive) spectral sets</br>
</br>
Siren also has special classes that read spectral samples from Greg Sandell's SHARC timbre database (http://www.timbre.ws/sharc/files/README.txt); these sampled spectra can be used for sum-of-sines synthesis. The following example illustrates the loading of a SHARC sample for a tuba. It assumes that the SHARC database is somewhere in the user's data folder list.</br>
&emsp;[SHARCInstrument fromDir: 'tuba'] i</br>
&emsp;[(Function from: (((SHARCInstrument fromDir: 'tuba') samples at: #c3) asWavetable: 1024)) edit: 512] d</br>
&emsp;[((SHARCInstrument fromDir: 'tuba') samples at: #c3) asSumOfSines] i</br>
</br>
To load the entire SHARC database, use the following.</br>
&emsp;[SHARCInstrument loadOrchDir: 'sharc'] d</br>
&emsp;[SHARCInstrument orchestra] i</br>
</br>
There's an example of using a SHARC spectrum sample set to drive a CSL sum-of-sines synthesizer via OSC in this method</br>
&emsp;[OSCVoice sosExample1]&emsp;db</br>
</br>
Extending the Function Framework</br>
</br>
As with other areas of Siren, the Function framework is designed for ease of extension. One can construct a new type of function with a simple instance creation method and implementation of the at: method. There are also often cases where one needs an additional behavior in the base Function class. For extending the behavior of functions with respect to events and event lists, you can customize the eventList apply: function.</br>
</p><hr><h3 id="EventGeneratorsforMiddle-levelMusicalStructures">13 - EventGenerators for Middle-level Musical Structures</h3>Siren Event Generators</br>
</br>
The EventGenerator and EventModifier packages provide for music description and performance using generic or composition-specific middle-level objects. Event generators are used to represent the common structures of the musical vocabulary such as chords, clusters, progressions, ostinati, or algorithms. Each event generator subclass knows how it is described--e.g., a chord with a root and an inversion, or an ostinato with an event list and repeat rate--and can perform itself once or repeatedly, acting like a Smalltalk-80 control structure or returning a static event list for further processing. </br>
</br>
EventModifier objects generally hold onto a function and a property name; they can be told to apply their functions to the named property of an event list lazily or eagerly. Event generators and modifiers are described in more detail in the 1989 ICMC paper (see the file Doc/icmc.89.egens.pdf).</br>
</br>
Examples</br>
</br>
Clusters and Chords are simple one-dimensional event generators.</br>
</br>
&emsp;[(Siren.Cluster dur: 2.0</br>
&emsp;&emsp;pitchSet: #(48 50 52 54 56)</br>
&emsp;&emsp;ampl: 100</br>
&emsp;&emsp;voice: 1) open]</br>
</br>
&emsp;[((Chord majorTetradOn: 'f4' inversion: 0) duration: 1.0) open]</br>
</br>
Rolls are also-1-D, but are rhythm-only.</br>
Create and play a simple drum roll--another 1-D event generator.</br>
</br>
&emsp;[((Roll length: 2000 rhythm: 50 note: 60) ampl: 80) open]</br>
</br>
&emsp;[((Roll length: 2000 rhythm: 50 note: 60) ampl: 80) eventList playOn: MIDIVoice default]</br>
</br>
Clouds are stochastic descriptions of event lists whereby one can give the numerical range of each of several standard properties.</br>
</br>
Create and edit a low 6 second stochastic cloud with 5 events per second.</br>
</br>
&emsp;[ | c |</br>
&emsp;c := (Cloud dur: 6&emsp;&emsp;&emsp;"lasts 6 sec."</br>
&emsp;&emsp;pitch: (48 to: 60)  &emsp;&emsp;"with pitches in this range"</br>
&emsp;&emsp;ampl: (80 to: 120) &emsp;&emsp;"and amplitudes in this range"</br>
&emsp;&emsp;voice: (1 to: 1)&emsp;&emsp;&emsp;"select from these voices"</br>
&emsp;&emsp;density: 5) eventList.&emsp;"play 5 notes per sec. and get the event list"</br>
&emsp;c open]</br>
</br>
To create a dynamic cloud, one gives starting and ending ranges for the properties.</br>
Play a 6-second cloud that goes from low to high and soft to loud.</br>
</br>
&emsp;[(DynamicCloud dur: 6  </br>
&emsp;&emsp;pitch: #((30 to: 49) (60 to: 60))&emsp;"given starting and ending selection ranges"</br>
&emsp;&emsp;ampl: #((20 to: 40) (90 to: 120))</br>
&emsp;&emsp;voice: #((1) (1))</br>
&emsp;&emsp;density: 12) open]</br>
</br>
A selection cloud selects values from the data arrays that are given in the instance creation method.</br>
</br>
&emsp;[(SelectionCloud dur: 4  </br>
&emsp;&emsp;pitch: #(32 40 48 50 52 55 57 )</br>
&emsp;&emsp;ampl: #(80 40 120)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 8) open]</br>
</br>
&emsp;[(SelectionCloud dur: 4  </br>
&emsp;&emsp;pitch: ((NeapolitanMinor root: N do) asPitchesInOctave: 4)</br>
&emsp;&emsp;ampl: #(80 40 120)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 12) open]</br>
</br>
By obvious extension, a dynamic selection cloud allows one to specify the start and finish selection sets.</br>
The first example blow plays a selection cloud that makes a transition from one triad to another.</br>
</br>
&emsp;[(DynamicSelectionCloud dur: 6</br>
&emsp;&emsp;pitch: #( #(48 50 52) #(72 74 76) )&emsp;"starting and ending pitch sets"</br>
&emsp;&emsp;ampl: #(60 80 120)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 12) open]</br>
</br>
&emsp;[ | set1 set2 |</br>
&emsp;set1 := ((Oriental root: N do) asPitchesInOctave: 4).</br>
&emsp;set2 := ((Oriental root: N sol) asPitchesInOctave: 2).</br>
&emsp;(DynamicSelectionCloud dur: 6</br>
&emsp;&emsp;pitch: (Array with: set1 with: set2)</br>
&emsp;&emsp;ampl: #(60 80 120)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 12) open]</br>
</br>
&emsp;[ | c |</br>
&emsp;c := (DynamicSelectionCloud dur: 6</br>
&emsp;&emsp;pitch: #( #(53 50 52) #(72 74 75) )&emsp;"starting and ending pitch sets"</br>
&emsp;&emsp;ampl: #(40 60 30)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 12) eventList.</br>
</br>
&emsp;c addAll: (DynamicSelectionCloud dur: 6</br>
&emsp;&emsp;pitch: #( #(76 78 80) #(60 62 64) )&emsp;"starting and ending pitch sets"</br>
&emsp;&emsp;ampl: #(40 60 30)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 16) eventList.</br>
&emsp;c open]</br>
</br>
The extended DynamicSelectionCloud uses a multi-part pitch set  of the format (time -> chord) (time -> chord) ... as in the following example, which creates a list of the tetrachords of the Neapolitan minor scale, then scrambles the list, then transposes every second chord up two octaves, then plays an extended dynnamic selection cloud made from this list.</br>
&emsp;</br>
&emsp;[ | score chords list |&emsp;&emsp;&emsp;"generate the tetrads from the selected scale; scramble the order"</br>
&emsp;chords := ((NeapolitanMinor root: N do) generateChordsPoly: 4 inOctave: 2) scrambled.</br>
&emsp;list :=  OrderedCollection new.</br>
&emsp;1 to: 7 do:</br>
&emsp;&emsp;[ :ind |&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"shift every other one up 2 octaves"</br>
&emsp;&emsp;ind even ifTrue: [list add: ((ind - 1) * 3 -> ((chords at: ind) collect: [ :no | no + 24]))]</br>
&emsp;&emsp;&emsp;ifFalse: [list add: ((ind - 1) * 3 -> (chords at: ind))]].</br>
&emsp;score := (ExtDynamicSelectionCloud dur: 8&emsp;"now make a cloud from these"</br>
&emsp;&emsp;pitch: list</br>
&emsp;&emsp;ampl: 60</br>
&emsp;&emsp;voice: nil</br>
&emsp;&emsp;density: 10) eventList.</br>
&emsp;score eventsDo: [ :ev |&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"plug in the properties for FM"</br>
&emsp;&emsp;ev inst: '/i1/pn'.</br>
&emsp;&emsp;ev modIndex: 2.0.</br>
&emsp;&emsp;ev ratio: 1.02.</br>
&emsp;&emsp;ev pos: 0.0].</br>
&emsp;SirenSession eventList: 'EvGens/dsCloud1' put: score.</br>
&emsp;score open]</br>
</br>
As an example of a more sophisticated event generator, Mark Lentczner's bell peals ring the changes.</br>
</br>
&emsp;[(Peal upon: #(60 62 65)) eventList open]</br>
</br>
&emsp;[ | peal list |</br>
&emsp;peal := Peal upon: #(60 62 65 67).</br>
&emsp;list := EventList new.</br>
&emsp;peal playOn: list durations: 240 meter: 100 at: 0.</br>
"&emsp;list voice: #marimba."</br>
"&emsp;list playOn: MIDIVoice default."</br>
&emsp;list open]</br>
</br>
One can get an event generator's event list and process it using Smalltalk code blocks, as in this example, which takes a simple selection cloud and applies both a crescendo function and a beat pattern to it.</br>
</br>
&emsp;[ | dur cloud list ramp1 ramp2 pattern start |</br>
&emsp;dur := 6.</br>
&emsp;cloud := (SelectionCloud</br>
&emsp;&emsp;dur: dur  </br>
&emsp;&emsp;pitch: ((NeapolitanMinor root: N do) asPitchesInOctave: 4)</br>
&emsp;&emsp;ampl: #(80)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 10).</br>
&emsp;list := cloud eventList.</br>
&emsp;SirenSession eventList: 'Examples/NeapCloud' put: list.</br>
&emsp;ramp1 := (ExponentialFunction from: #((0 0.2 5) (1 0.8))).&emsp;"2 ramps that will be summed"</br>
&emsp;ramp2 := (ExponentialFunction from: #((0 0 5) (0.2 0.2))).</br>
&emsp;pattern := #(0.1 0.1 0.2 0.2 0.1).&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"beat pattern"</br>
&emsp;start := 0.</br>
&emsp;1 to: list size do: &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"loop through the list's events"</br>
&emsp;&emsp;[ :count | | assoc |</br>
&emsp;&emsp;assoc := list events at: count.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"get the current association"</br>
&emsp;&emsp;assoc key: start sec.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"reset the start time"</br>
&emsp;&emsp;start := start + (pattern at: (count \\ pattern size) + 1).</br>
&emsp;&emsp;scale := (ramp1 at: (count / list size)) + (ramp2 at: ((count asFloat / list size) mod: ramp2 size)).</br>
&emsp;&emsp;assoc value ampl: (scale * 80) velocity].&emsp;&emsp;&emsp;&emsp;&emsp;"scale the amplitude"</br>
&emsp;list open]</br>
</br>
Extending EventGenerators</br>
</br>
New kinds of event generator can be programmed with constructor and eventList: methods. The framework facilitates the design of fancier behaviors and parameterized event generators.</br>
</p><hr><h3 id="Score11EventGenerators">14 - Score11 EventGenerators</h3>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.html</br>
</br>
Instance Variables:</br>
&emsp;generators&emsp;<Dictionary of (prop-name -> data)>&emsp;the parameter blocks of the score11 instrument</br>
</br>
Examples:</br>
</br>
instrument 1 0 10;&emsp;< Instrument 1 starts at time 0 and plays for 10 beats.</br>
&emsp;parameter 3 1; &emsp;< Each note lasts 1 beat</br>
end;          &emsp;&emsp;&emsp;< This finishes the I-block</br>
</br>
i1 0 5;</br>
&emsp;p3 rh 4/8*6/4;</br>
&emsp;p4 no c4/d/e/f/g/a/b/c5;</br>
&emsp;p5 1.0 1.0 5.0;    &emsp;&emsp;&emsp;< 100% of values between 1.0 and 5.0</br>
&emsp;p6 mo 5 1000 2000;&emsp;&emsp;< move from 1000 to 2000 in 5 beats</br>
end;</br>
</br>
Standard parameter maps -- the SCORE-11 constant parameter meanings are:</br>
</br>
      p1 = Instrument number</br>
      p2 = Starting time for this note (in beats) (not normally used)</br>
      p3 = Duration for this note (in beats)</br>
      p4 = Pitch (or frequency)</br>
      p5 = Amplitude value (0 - 32000)</br>
</br>
Smalltalk examples</br>
</br>
&emsp;s11 := (Score11 instr: 1 from: 0 to: 10)</br>
&emsp;&emsp;add: #p3 -> (#rh -> '4/8*6/4');</br>
&emsp;&emsp;add: #p4 -> (#no -> 'c4/d/e/f/g/a/b/c5');</br>
&emsp;&emsp;add: #p5 -> #(1.0 1.0 5.0);</br>
&emsp;&emsp;add: #p6 -> (#mo -> #(5 1000 2000)).</br>
&emsp;s11 events</br>
</br>
&emsp;"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) </br>
&emsp;&emsp;add: #p3 -> (#rh -> '4//8////4//'); </br>
&emsp;&emsp;add: #p4 -> (#no -> 'c4/d/e/f/g/a/b/c5'); </br>
&emsp;&emsp;add: #p5 -> #(1.0 1.0 5.0); </br>
&emsp;&emsp;add: #p6 -> (#mo -> #(5 1000 2000))) </br>
&emsp;eventList"</br>
</br>
&emsp;"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) </br>
&emsp;&emsp;add: #p3 -> (#rh -> '4/8*4/6*3/4/'); </br>
&emsp;&emsp;add: #p4 -> (#no -> 'c4/d/e/f/g/a/b/c5'); </br>
&emsp;&emsp;add: #p5 -> (#mo -> #(10 10 100));</br>
&emsp;&emsp;add: #p6 -> #(1.0 -1.0 1.0)) </br>
&emsp;eventList"</br>
</br>
&emsp;[ | s11 |</br>
&emsp;s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) </br>
&emsp;&emsp;add: #p3 -> (#rh -> '4/8*4/6*3/4/'); </br>
&emsp;&emsp;add: #p4 -> (#no -> 'c4/d/e/f/g/a/b/c5'); </br>
&emsp;&emsp;add: #p5 -> (#mo -> #(10 10 100));</br>
&emsp;&emsp;add: #p6 -> #(1.0 -1.0 1.0);</br>
&emsp;&emsp;add: #p7 -> #(0.5 1 2  0.5 100 200);</br>
&emsp;&emsp;add: #p8 -> (#se -> '10 1 3 5 7 9'));</br>
&emsp;&emsp;add: #p9 -> (#mx -> #(10 1 100))).</br>
&emsp;s11 assign: #p6 to: #position:.</br>
&emsp;s11 assign: #p7 to: #attack:.</br>
&emsp;s11 eventList inspect ]</br>
</br>
&emsp;[ | s11 |&emsp;&emsp;&emsp;"test multi-segment moves"</br>
&emsp;s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) </br>
&emsp;&emsp;add: #p3 -> (#rh -> 16); </br>
&emsp;&emsp;add: #p4 -> (#no -> 'c4/d/e/f/g/a/b/c5'); </br>
&emsp;&emsp;add: #p5 -> (#mo -> #(7 5 100  3 100 5))).</br>
&emsp;s11 tempo: #(10 60 120).</br>
&emsp;s11 eventList inspect ]</br>
</br>
&emsp;[ | s11 |&emsp;&emsp;&emsp;"test dotted values"</br>
&emsp;s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) </br>
&emsp;&emsp;add: #p3 -> (#rh -> '4/4./4../8'); </br>
&emsp;&emsp;add: #p4 -> (#no -> 'c4/d/e/f/g/a/b/c5'); </br>
&emsp;&emsp;add: #p5 -> (#mo -> #(7 5 100  3 100 5))).</br>
&emsp;s11 tempo: #(10 60 120).</br>
&emsp;s11 eventList inspect ]</br>
</br>
&emsp;[ | s11 |&emsp;&emsp;&emsp;"test rests"</br>
&emsp;s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) </br>
&emsp;&emsp;add: #p3 -> (#rh -> '4/-4/8/-8'); </br>
&emsp;&emsp;add: #p4 -> (#no -> 'c4/d/e/f/g/a/b/c5'); </br>
&emsp;&emsp;add: #p5 -> (#mo -> #(7 5 100  3 100 5))).</br>
&emsp;s11 tempo: #(10 60 120).</br>
&emsp;s11 eventList inspect ]</br>
</br>
&emsp;[ | s11 |&emsp;&emsp;&emsp;"test complex movex"</br>
&emsp;s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) </br>
&emsp;&emsp;add: #p3 -> (#rh -> '8/'); </br>
&emsp;&emsp;add: #p4 -> (#mx -> '5 100 120 , 2000 2400 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;4 2050 2060 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;6 2000 2100 , 700 1100' )).</br>
&emsp;s11 eventList inspect ]</br>
</br>
&emsp;[ | s11 |&emsp;&emsp;&emsp;"test complex movex 2"</br>
&emsp;s11 := ((Siren.Score11 instr: 1 from: 0 to: 8) </br>
&emsp;&emsp;add: #p3 -> (#rh -> '32/'); </br>
&emsp;&emsp;add: #p4 -> (#mx -> '3 140 190 , 400 440 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2 440 460 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3 400 400 , 150 250' )).</br>
&emsp;s11 eventList open ]</br>
</br>
----</br>
</br>
&emsp;[ | s11 |&emsp;&emsp;&emsp;"BOOH part 1"</br>
&emsp;s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) </br>
&emsp;&emsp;add: #p3 -> (#mx -> '15 .4 .5 , .05 .14 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;15 .1 .15 , .5 .4 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;20 .5 .3 , .1 .13 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;25 .2 .1 , .6 .6 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;25 .5 .7 , .1 .06 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;20 .12 .08 , .5 .5'); </br>
&emsp;&emsp;add: #p4 -> (#mx -> '20 2000 3000 , 2000 2100 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;20 2050 2050 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;30 2000 2100 , 2200 1600 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;20 2400 2500 , 2800 2000 /</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;30 2400 2400 , 2200 2100'); </br>
&emsp;&emsp;add: (#p5 -> 70);</br>
&emsp;&emsp;add: #p6 -> (#mx -> '100 1 1 , 1 1 / 20 1 1 , .9 1.1');</br>
&emsp;&emsp;add: #p7 -> #(1.0 -1.0 1.0) ).</br>
&emsp;s11 du: 303.</br>
&emsp;s11 assign: #p6 to: #gliss:.</br>
&emsp;s11 assign: #p7 to: #position:.</br>
&emsp;s11 eventList  ]</br>
</br>
Keywords requiring a parameter number:</br>
&emsp;1. funcs (not implemented)</br>
&emsp;2. move - move "number of beats for change" "first value" "second value"</br>
&emsp;3. movex - movex "number of beats for change" "first value" "second value"</br>
&emsp;4. notes - symbolic note names</br>
&emsp;5. numbers - numerical sequences</br>
&emsp;6. rhythms - rhythmic notations</br>
&emsp;7. rlist</br>
&emsp;8. rnotes</br>
&emsp;9. sets - selection from sets</br>
</br>
Keywords not using a parameter number:</br>
&emsp;1. ampfac</br>
&emsp;2. beat</br>
&emsp;3. duty_factor</br>
&emsp;4. end</br>
&emsp;5. instrument (valid as 'i')</br>
&emsp;6. parameter (valid as 'p')</br>
&emsp;7. rdeviation</br>
&emsp;8. rrests</br>
&emsp;9. rseed</br>
&emsp;10. tempo</br>
&emsp;11. tfactor</br>
</br>
</br>
Score11>>writeP3RH:into: (RestEvent is Undeclared) </br>
Score11>>writeP3RH:into: (RestEvent is Undeclared) </br>
Score11 class>>chorale1 (InputState is Undeclared) </br>
Score11 class>>chorale2 (InputState is Undeclared) </br>
Score11 class>>melody1 (InputState is Undeclared) </br>
Score11 class>>melody1b (InputState is Undeclared) </br>
Score11 class>>test14 (InputState is Undeclared) </br>
Score11 class>>booh1 (InputState is Undeclared) </br>
Score11 class>>booh2 (InputState is Undeclared) </br>
Score11 class>>booh3 (InputState is Undeclared) </br>
Score11 class>>sleepingSword1 (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword1 (BohlenPierceScale is Undeclared) </br>
Score11 class>>sleepingSword1 (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword1 (InputState is Undeclared) </br>
Score11 class>>sleepingSword2 (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword2 (BohlenPierceScale is Undeclared) </br>
Score11 class>>sleepingSword2 (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword2 (InputState is Undeclared) </br>
Score11 class>>sleepingSword3 (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword3 (BohlenPierceScale is Undeclared) </br>
Score11 class>>sleepingSword3 (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword3 (InputState is Undeclared) </br>
Score11 class>>sleepingSword3b (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword3b (BohlenPierceScale is Undeclared) </br>
Score11 class>>sleepingSword3b (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword3b (InputState is Undeclared) </br>
Score11 class>>sleepingSword4 (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword4 (BohlenPierceScale is Undeclared) </br>
Score11 class>>sleepingSword4 (PentatonicScale is Undeclared) </br>
Score11 class>>sleepingSword4 (InputState is Undeclared) </br>
Score11>>writeP3RH:into: (RestEvent is Undeclared) </br>
</p><hr><h3 id="EventModifiersandMappingFunctions">15 - EventModifiers and Mapping Functions</h3>Using EventModifiers</br>
</br>
One can apply functions to the properties of event lists, as in the following example, which creates a drum roll and applies a crescendo modifier to it.</br>
</br>
&emsp;[ | roll decresc |</br>
&emsp;roll := ((Roll length: 3 rhythm: 0.06 note: 60) ampl: 120) eventList.</br>
&emsp;decresc := Swell function: (ExponentialFunction from: #((0 0 2) (1 1))).</br>
&emsp;decresc applyTo: roll.</br>
&emsp;roll open]</br>
</br>
Similarly, the following changes the tempo of the drum roll.</br>
</br>
&emsp;[ | roll rub |</br>
&emsp;roll := ((Roll length: 5 rhythm: 0.1 note: 60) ampl: 80) eventList.</br>
&emsp;rub := Rubato function: (LinearFunction from: #((0 1) (1 0.5))).</br>
&emsp;rub applyTo: roll.</br>
&emsp;roll open]</br>
</br>
or this example, where the rubato is a sine curve with an offset</br>
</br>
&emsp;[ | roll sin rub |</br>
&emsp;roll := ((Roll length: 5 rhythm: 0.1 note: 60) ampl: 80) eventList.</br>
&emsp;sin := (FourierSummation from: #((1 0.1 0))) + 1.0.</br>
&emsp;rub := Rubato function: sin.</br>
&emsp;rub applyTo: roll.</br>
&emsp;roll open]</br>
</br>
All of these work by sending the message </br>
&emsp;anEventList applyFunction: aFunction to: aSelector startingAt: sTime</br>
which can be used for many other situations.</br>
</br>
There are many other examples of using functions with event lists in the MIDI, OSC, and CSL I/O examples.</br>
</p><hr><h3 id="SchedulersandReal-timeIOforSiren">16 - Schedulers and Real-time IO for Siren</h3>Schedulers and Real-time Performance</br>
</br>
Event lists have events sorted by their relative start times. One "performs" event lists by placing them in a schedule for performance. A schedule can have one or more client objects (usually event lists whose items are simple events, sound events, or function events) that are able to do something in response to the</br>
&emsp;scheduleAt: aTime</br>
message. The return value from this message is assumed to be the delay (in usec) before calling the client again. Event lists typically perform the next event (by passing it to its voice) and answer the relative delta time to the next event (which may be 0 for simultaneous events).</br>
</br>
The EventScheduler instance can be accessed by a class message (instance) to class EventScheduler; it can be used to sequence and synchronize event lists that may include a variety of events, event lists, and voices. The Scheduler messages for adding a new "client" and running the schedule are as shown below.</br>
</br>
Play some random notes on the devault voice</br>
&emsp;[EventScheduler addClient: (EventList randomExample: 20) at: 500 msec.</br>
&emsp; EventScheduler run]</br>
</br>
Run the simple flashing rectangles example</br>
&emsp;[EventScheduler addClient: ActionEvent listExample in: 100 msec; run]</br>
&emsp;"Window currentWindow refresh"</br>
</br>
House-keeping messages</br>
&emsp;[EventScheduler isRunning]</br>
&emsp;[EventScheduler interrupt]</br>
&emsp;[EventScheduler flush]</br>
&emsp;[EventScheduler initialize]</br>
</br>
Get the instance</br>
&emsp;[EventScheduler instance]</br>
</br>
If the SirenUtility vertbosity is set to 2 (very verbose), and you hold down the <SHIFT> key, the schedule will print a timer to the Transcript (useful for testing).</br>
</br>
The standard voices for MIDI and OSC output use the built-in schedule for their timing.</br>
Play 64 notes lasting 80 msec--a good test of real-time performance.</br>
This is scheduled in the port, i.e., at the lowest-possible level.</br>
&emsp;[MIDIPort testRandomPlay2: 64 dur: 80]</br>
</br>
Test a roll--it's easier to hear scheduler jitter here. The first example uses the low-level port delays. (try it several times to hear the changes in the jitter.)</br>
&emsp;[MIDIPort testRoll: 40 dur: 60]</br>
</br>
This should sound about the same, but plays an event generator over the the high-level scheduler.</br>
&emsp;[((Roll length: 2400 rhythm: 60 note: 60) ampl: 96) play]</br>
</br>
This example uses the high-level EventScheduler to play a scale. (Jitter is harder to hear here.)</br>
&emsp;[MIDIDevice scheduleExample]</br>
</br>
Scheduler Internals</br>
</br>
The EventScheduler instance (Schedule) holds onto 2 SEventQueues, one for normal clients, and one for timers. The SEventQueue is a simple doubly-linked list of ScheduleRecord objects sorted by start time (with a class pool of ScheduleRecords and an efficient insert method). All times are in microseconds (meaning long integers).</br>
</br>
The main scheduler loop is in the method run forks a process running the loop</br>
&emsp;[running] whileTrue: [self callNextAppointment]</br>
It's the callNextAppointment method that looks for a client or timer that's ready and schedules it. If there's nothing to do, the loop sleeps a bit; the actual amount of the inner delay is a class variable.</br>
</p><hr><h3 id="VoicesandProperty-to-ParameterMapping">17 - Voices and Property-to-Parameter Mapping</h3>Voices and Ports in Siren</br>
</br>
The "performance" of events takes place via voice objects. Event properties are assumed to be independent of the parameters of any synthesis instrument or algorithm. A voice object is a "property-to-parameter mapper" that knows about one or more output or input formats for Smoke data. There are voice "device drivers" for common file storage formats--such as note lists file formats for various software sound synthesis packages or MIDI files--or for use with real-time schedulers connected to MIDI, OSC, CSL, or SuperCollider drivers. These classes can be refined to add new event and signal file formats or multilevel mapping (e.g., for MIDI system exclusive messages) in an abstract way. </br>
</br>
Voice objects can also read input streams (e.g., real-time controller data or output from a coprocess), and send messages to other voices, schedulers, event modifiers or event generators. This is how one uses the system for real-time control of complex structures.</br>
</br>
The actual property-to-parameter mapping is often controlled by a dictionary or a block (the parameter map) that takes the properties of an event and creates a statement or command for some output format. This allows the user to customize the voices at run-time (see the OSCVoice for good examples).</br>
</br>
Voices and Schedulers</br>
</br>
Some voices are "timeless" (e.g., MIDI file readers); they operate at full speed regardless of the relative time of the event list they read or write. Others assume that some scheduler hands events to their voices in real time during performance. The EventScheduler does just this; it can be used to sequence and synchronize event lists that may include a variety of voices.</br>
</br>
Examples</br>
</br>
Create a random event list and write it out to notelist files in any of several formats. Edit the file.</br>
</br>
&emsp;[CmixVoice randomExampleToFileAndEdit]</br>
&emsp;[CmusicVoice randomExampleToFileAndEdit]</br>
&emsp;[CsoundVoice randomExampleToFileAndEdit]</br>
&emsp;[SuperColliderVoice randomExampleToFileAndEdit]</br>
</br>
Create an event list of 20 notes with semi-random values and play it on a MIDI output voice.</br>
</br>
&emsp;[(EventList randomExample: 20) playOn: MIDIVoice default]</br>
</br>
Use the same random list creation method, but add three lists in parallel.</br>
</br>
&emsp;[((EventList newNamed: #pRand)</br>
&emsp;&emsp;&emsp;addAll: (EventList randomExample: 40);</br>
&emsp;&emsp;&emsp;addAll: (EventList randomExample: 40);</br>
&emsp;&emsp;&emsp;addAll: (EventList randomExample: 40))</br>
&emsp;&emsp;playOn: MIDIVoice new]</br>
</br>
Complex Multimedia Example: Generate and play a mixed-voice event list; a cloud plays alternating notes on MIDI and built-in synthesis, and a list of action events flashes screen rectangles in parallel.</br>
</br>
&emsp;[ | el |</br>
&emsp;el := (Cloud dur: 6&emsp;&emsp;&emsp;&emsp;"Create a 6-second stochastic cloud"</br>
&emsp;&emsp;pitch: (48 to: 60)&emsp;&emsp;&emsp;&emsp;"choose pitches in this range"</br>
&emsp;&emsp;ampl: (40 to: 70) &emsp;&emsp;&emsp;&emsp;"choose amplitudes in this range"</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"select from these 2 voices"</br>
&emsp;&emsp;voice: (Array with: (MIDIVoice default) with: (OSCVoice default))</br>
&emsp;&emsp;density: 5) eventList.&emsp;&emsp;&emsp;"play 5 notes per sec. and get the events"</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"add some animation events"</br>
&emsp;el addAll: ActionEvent listExample.</br>
&emsp;el play]&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"and play the merged event list"</br>
</br>
Defaults</br>
</br>
The Voice class has a default subclass. This can be changed with the SirenUtility GUI.</br>
&emsp;[Voice default] i</br>
</br>
This can be changed with the Siren Utility view.</br>
As with EventLists, Voices can also be stored in a global dictionary and acccessed by name.</br>
</br>
&emsp;[SirenSession voice: #oscFM put: (OSCVoice map: #pMapForCSLSimpleFM)] d</br>
&emsp;[SirenSession voice: #defaultMIDI put: (MIDIVoice named: 'oboe' onDevice: (MIDIDevice on: 1) channel: 1)] d</br>
&emsp;[SirenSession voiceNamed: #oscFM] i</br>
</br>
MIDI Input Voices</br>
</br>
The MIDI file voice can read standard MIDI file format and generate a Siren event list, as in the example below.</br>
</br>
&emsp;(MIDIFileVoice newOn: 'K194.MID')</br>
&emsp;&emsp;readOnto: (EventList newNamed: #K194).</br>
&emsp;(EventList named: #K194) open.</br>
</br>
Extending the Voice Framework</br>
</br>
By adding new voice classes, you can add parsers and generators for new score file formats, or extend the system with new real-time output driver interfaces. Look at the uses of the parameter maps in the notelist voices, or the OSC and CSL voices.</br>
</p><hr><h3 id="MIDIIOandControlinSiren">18 - MIDI IO and Control in Siren</h3>About Siren MIDI</br>
</br>
Siren includes a portable MIDI I/O framework that consists of an abstract I/O port class (MIDIPort), a plug-in that uses the DLLCC interface, and a C-language interface module that talks to the platform-independent PortMIDI library. The higher-level model is that a MIDI voice object holds onto a MIDI device and a channel. The MIDI device object is connected to a MIDI port. For example, the verbose way to create the default MIDI voice would be to say</br>
&emsp;MIDIVoice on: (MIDIDevice on: (MIDIPort default openOutput))</br>
</br>
The voice object gives us the standard voice behavior (like event mapping and scheduling). The MIDI device allows us to model the device-specific messages supported by some devices. (I used to use micro-tonal extended messages on a few different hardware synths.) The MIDIPort is used for the interface betweeen Siren and external MIDI drivers and devices. It implements both note-oriented (e.g., play: pitch at: aDelay dur: aDur amp: anAmp voice: voice), and data-oriented (e.g., put: data at: delay length: size) behaviors for MIDI I/O.</br>
</br>
There is typically only one instance of MIDIPort; the messages new, default, and instance all answer the sole instance. MIDIPorts use observers (dependency) to signal input data--objects wishing to receive input should register themselves as dependents of a port. In the default Siren implementation, the scheduler is all in Smalltalk, and only the simplest MIDI driver is assumed.</br>
</br>
MIDI Implementation: The class PortMIDIPort implements the low-level MIDI I/O messages by talking to the PortMidiInterface external class, which is a front-end to C-language glue code that talks to the PortMIDI library. If you set the verbosity to 2 and open a port, it will print your entire device table to the VM's standard output and to the Transcript; for my system, this looks like the following:</br>
</br>
2007 set-up</br>
</br>
Midi Device Table</br>
&emsp;0: IAC Driver IAC Bus 1 - in</br>
&emsp;1: IAC Driver IAC Bus 2 - in</br>
&emsp;2: IAC Driver IAC Bus 3 - in</br>
&emsp;3: PC-1600X - in</br>
&emsp;4: StudioLogic SL-161 - in</br>
&emsp;5: Tascam FW-1804 FW-1804 Control Port - in</br>
&emsp;6: IAC Driver IAC Bus 1 - out</br>
&emsp;7: IAC Driver IAC Bus 2 - out</br>
&emsp;8: IAC Driver IAC Bus 3 - out</br>
&emsp;9: Tascam FW-1804 FW-1804 Port 1 - out</br>
&emsp;10: EM-100 - out</br>
&emsp;11: Tascam FW-1804 FW-1804 Port 3 - out</br>
&emsp;12: Tascam FW-1804 FW-1804 Port 4 - out</br>
&emsp;13: Tascam FW-1804 FW-1804 Control Port - out</br>
</br>
More recent, smaller set-up</br>
</br>
MIDI devices (4):</br>
&emsp;0: CoreMIDI, Kurzweil   in -- default in</br>
&emsp;1: CoreMIDI, PV16X   in</br>
&emsp;2: CoreMIDI, Kurzweil   out -- default out</br>
&emsp;3: CoreMIDI, MIDIPLUS TBOX 2x2 Midi Out 2   out</br>
</br>
2022 set-up</br>
</br>
Driver reports</br>
</br>
&emsp;MIDI devices (8):</br>
&emsp;&emsp;0: CoreMIDI, MIDIPLUS TBOX 2x2 Midi In 1, in -- default in</br>
&emsp;&emsp;1: CoreMIDI, Faders, in</br>
&emsp;&emsp;2: CoreMIDI, IAC Driver Bus 1, in</br>
&emsp;&emsp;3: CoreMIDI, Nord Stage 3 MIDI Output, in</br>
&emsp;&emsp;4: CoreMIDI, Nord Stage 3, out -- default out</br>
&emsp;&emsp;5: CoreMIDI, MIDIPLUS TBOX 2x2 Midi Out 2, out</br>
&emsp;&emsp;6: CoreMIDI, IAC Driver Bus 1, out</br>
&emsp;&emsp;7: CoreMIDI, Nord Stage 3 MIDI Input, out</br>
</br>
ST Library reports</br>
</br>
&emsp;MIDI Device Table</br>
&emsp;&emsp;# 0 - MIDIPLUS TBOX 2x2 Midi In 1 - in *</br>
&emsp;&emsp;# 1 - Faders - in</br>
&emsp;&emsp;# 2 - IAC Driver Bus 1 - in</br>
&emsp;&emsp;# 3 - Nord Stage 3 MIDI Output - in</br>
&emsp;&emsp;# 4 - Nord Stage 3 - out *</br>
&emsp;&emsp;# 5 - MIDIPLUS TBOX 2x2 Midi Out 2 - out</br>
&emsp;&emsp;# 6 - IAC Driver Bus 1 - out</br>
&emsp;&emsp;# 7 - Nord Stage 3 MIDI Input - out</br>
&emsp;</br>
</br>
MIDI Tests and Examples</br>
</br>
Basic Tests</br>
</br>
Edit the methods MIDIPort initialize to suit your setup.</br>
</br>
Try to open and close the MIDI port (this also reports to the transcript and dumps a device list to the VM's stdout).</br>
&emsp;[MIDIPort testOpenClose]</br>
</br>
Open MIDI, play a 1-sec. note.</br>
&emsp;[MIDIPort testANote]</br>
</br>
Open MIDI, play a fast scale.</br>
&emsp;[MIDIPort testAScale]</br>
</br>
Open MIDI, play notes based on the mouse position (x --> voice; y --> pitch) until mouse down.</br>
&emsp;[MIDIPort testMouseMIDI]</br>
&emsp;[MIDIPort allNotesOff]</br>
</br>
EventScheduler interrupt; flush</br>
</br>
</br>
Close down and clean up.</br>
&emsp;[MIDIPort cleanUp]</br>
</br>
Using voices</br>
&emsp;[MIDIVoice randomExample]</br>
&emsp;[MIDIVoice scaleExample]</br>
&emsp;[MIDIVoice voiceInspect]</br>
</br>
General MIDI Maps and Program Changes</br>
</br>
"Demonstrate program change by setting up an organ instrument to play on.</br>
&emsp;[MIDIPort testProgramChange]</br>
</br>
Down-load a general MIDI patch for a 4-voice organ.</br>
&emsp;[MIDIPort setupOrgan. Cluster example1]</br>
</br>
Down-load a general MIDI patch for a 16-voice percussion ensemble.</br>
&emsp;[MIDIPort setupTunedPercussion. MIDIPort testAScale]</br>
</br>
Or try these</br>
&emsp;[MIDIPort setAllInstrumentsTo: 'Tenor Sax'. MIDIPort testAScale]</br>
&emsp;[MIDIPort setAllInstrumentsTo: 'Music Box'. MIDIPort testAScale]</br>
</br>
Reset the GM map (for the first 16 instruments)</br>
&emsp;[MIDIPort setupDefaultGeneralMIDI]</br>
</br>
MIDI Input</br>
</br>
Open MIDI, try to read something--dump it to the transcript.</br>
&emsp;[MIDIPort testInput]</br>
&emsp;[MIDIPort dumpExample]</br>
</br>
Execute this to end the input test</br>
&emsp;[MIDIPort testInputStop]</br>
</br>
Get the port's pending input.</br>
&emsp;[MIDIPort default eventsAvailable]</br>
&emsp;[MIDIPort default readAll]</br>
&emsp;[MIDIPort default input]</br>
&emsp;[MIDIPort default resetInput]</br>
</br>
Set up a MIDI dump object as a dependent of the input port. Dump for 5 seconds,</br>
then turn off. The default update: method just dumps the MIDI packet into the transcript.</br>
&emsp;[MIDIPort dumpExample]</br>
</br>
This example captures notes to an event list for 5 seconds and opens an editor on it.</br>
&emsp;[MIDIDump exampleList]</br>
</br>
Set up uncached controller reading and dump input to the transcript.</br>
&emsp;[MIDIPort testControllerInput]</br>
&emsp;[MIDIPort testInputStop]</br>
</br>
Set up uncached controller reading--read controllers from lo to hi as an array and print it; </br>
stop on mouse press.</br>
&emsp;[MIDIPort testControllerCachingFrom: 48 to: 52]</br>
</br>
Real-time Performance Tests</br>
</br>
Play ''num'' random pitches spaced ''dur'' msec apart.</br>
This test creates the messages and does the scheduling right here.</br>
&emsp;[MIDIPort testRandomPlayLowLevel: 64 dur: 80]</br>
</br>
Play a roll of 'num' notes spaced 'dur' msec apart.</br>
This test creates the messages and does the scheduling right here.</br>
&emsp;[ObjectMemory compactingGC.</br>
&emsp;&emsp;MIDIPort testRollLowLevel: 20 dur: 80]</br>
</br>
&emsp;[ObjectMemory compactingGC.</br>
&emsp;&emsp;MIDIPort testRollLowLevel: 200 dur: 40]</br>
</br>
Continuous Control Tests</br>
</br>
Demonstrate control commands by playing a note and making a crescendo with the volume pedal.</br>
&emsp;[MIDIPort testControlContinuous]</br>
</br>
Demonstrate pitch-bend by playing two notes and bending them.</br>
&emsp;[MIDIPort testBend]</br>
</br>
Recording Continuous Controllers</br>
</br>
One can also record functions from input controlers, as in the following example, which reads MIDI controller 48 at a rate of 40 Hz for 5 seconds.</br>
</br>
&emsp;[MIDIPort testControllerRecording]</br>
</br>
Utilities</br>
</br>
ANO</br>
&emsp;[MIDIPort allNotesOff]</br>
</br>
Close down and clean up</br>
&emsp;[MIDIPort cleanUp]</br>
</br>
If things get wedged, do this</br>
&emsp;[PortMidiInterface unloadLibraries]</br>
</br>
For much more detail, see the class example messages in MIDIPort, or the tests in the PortMIDIPort and PortMidiInterface classes.</br>
</p><hr><h3 id="OpenSoundControl-OSCIO">19 - OpenSoundControl - OSC IO</h3>Siren and OpenSoundControl</br>
</br>
Siren includes an output voice that generates messages in the CNMAT OpenSoundControl (OSC) protocol  (http://www.cnmat.berkeley.edu/OpenSoundControl), which is sent out via UDP network packets to some synthesis server. We generally build these servers using CSL or SuperCollider, and then control them with set-up, event trigger, and control messages sent out from Siren.</br>
</br>
The verbosity flag in the SirenUtility class allows for logging of all OSC to the transcript; open a Siren utility panel and use the pop-up menu to set the verbosity to 2. To test the OSC I/O, look at the classes OSCPort and OSCVoice with the default host/port settings and several useful parameter maps. A parameter map is a Smalltalk block that takes an event as its argument and returns an OSC message object (or a bundle), as in the following example (don't execute this):</br>
</br>
&emsp;[ :event |  | arr |&emsp;&emsp;&emsp;"This block takes an event as its argument and answers a"</br>
&emsp;arr := Array&emsp;&emsp;&emsp;&emsp;"TypedOSCMessage for the address /note-on"</br>
&emsp;&emsp;&emsp;with: event duration asSec value</br>
&emsp;&emsp;&emsp;with: event pitch asHz value</br>
&emsp;&emsp;&emsp;with: event ampl asRatio value.</br>
&emsp;TypedOSCMessage for: '/note-on' with: arr]</br>
</br>
For simple debugging, Chandrasekhar Ramakrishnan wrote Occam, a stand-alone OSC-to-MIDI convertor for Mac OS X (http://www.mat.ucsb.edu/~c.ramakr/illposed/occam.html). You can also use the CNMAT dumpOSC utility to print out OSC messages. The following example demonstrates using OSC with the Occam convertor, to test OSC output using a MIDI synthesizer.</br>
</br>
&emsp;[OSCVoice midiScaleExample]</br>
</br>
There are also several examples that are set up to work with the CSL OSC server demos; if you have CSL, compile and start the "OSC_test" target, which sets of a simple server with 4 voices of FM synthesis and 4 sound file playback instruments. Look at the conditional compilation macros in the file OSC_main.cpp; there are several options, each of which compiles a different instrument library into the CSL OSC server.</br>
</br>
#define CSL_OSC_FM_SndFile&emsp;&emsp;// 4 voices of FM, 4 of SndFiles, and 1 bell</br>
//#define CSL_OSC_SAMPLER&emsp;&emsp;&emsp;// 16 voices of file playback</br>
//#define CSL_OSC_ADDER&emsp;&emsp;&emsp;// 16 voices of sum-of-sines synthesis</br>
</br>
Then you can try the OSCVoice examples that follow.</br>
</br>
&emsp;[OSCVoice fmExample1]</br>
&emsp;[OSCVoice sndExample1]</br>
</br>
These examples loop endlessly, so you have to interrupt or flush the scheduler to stop them</br>
</br>
&emsp;[OSCVoice fmExample2. &emsp;&emsp;5 wait.</br>
&emsp;OSCVoice sndExample2.&emsp;&emsp;5 wait.</br>
&emsp;OSCVoice fmExample4]</br>
&emsp;[EventScheduler flush]</br>
</br>
Siren OSC also supports control output, as in this example, which sends values from a linear envelope out to the address "/osc/1/ampl" at the rate of 4 Hz (use dumpOSC to view the results).</br>
</br>
&emsp;[OSCVoice functionExample]</br>
</br>
You could rewrite this to use the function's change threshold instead of a constant update rate.</br>
</br>
As an example that mixes both styles, the following expression plays a long low FM note and then uses Siren function objects to send continuous controls to make the note glissando down and pan from left to right.</br>
</br>
&emsp;[OSCVoice fmExample3]</br>
</br>
For more examples, set the default voice to OSC (using the Siren utility control panel) and run the built in examples on the other pages of this outline.</br>
</br>
----</br>
</br>
Default CSL Synthesis Server Instruments (see CSL7/Src/IO/OSC_main.cpp)</br>
</br>
&emsp;1 - 10 ---- 10 plucked strings</br>
&emsp;&emsp; "fff" - amp, pitch, pos</br>
&emsp;11 - 20 ---- 10 FM instruments</br>
&emsp;&emsp;"ffff" - dur amp pitch pos</br>
&emsp;&emsp;"ffffff" - dur, ampl, c_fr, m_fr, ind, pos</br>
&emsp;21 - 30 ---- 10 FM bells</br>
&emsp;&emsp; "fffffff" - dur, ampl, pitch,  gliss, rat,  ind,  pos</br>
&emsp;31 - 34 ---- 4 sound files (words)</br>
&emsp;&emsp;"ff" - amp, pos</br>
&emsp;35 - 50 ---- 16 SHARC SOS voices (different instruments)</br>
&emsp;&emsp;dur, ampl, pitch, pos</br>
&emsp;&emsp;dur, ampl, pitch, pos, att, dec, sus, rel</br>
&emsp;51 - 55 ---- 5 basic SHARC-spectrum instruments w vibrato</br>
&emsp;&emsp;dur, ampl, pitch, pos</br>
&emsp;&emsp;dur, ampl, pitch, pos, att, dec, sus, rel</br>
&emsp;56 - 61 ---- 5 SHARC-instrument additive cross-fade instruments w vibrato</br>
&emsp;&emsp;dur, ampl, pitch, pos</br>
&emsp;&emsp;dur, ampl, pitch, pos, att, dec, sus, rel</br>
</br>
----</br>
</br>
The liblo OSC library includes a useful test program called oscsend, which allows one to </br>
send OSC commands to a server from the UNIX shell.  To compile this tool, go to the </br>
CSL7/Libs/liblo-0.31/src/tools folder and use a shell command such as,</br>
</br>
&emsp;gcc -I../.. -g -O2 -o oscsend oscsend-oscsend.o /usr/local/lib/liblo.7.dylib -lpthread -lm</br>
</br>
to compile and link the oscsend command -- the Makefile may of may not work; it depends</br>
on where you installed the liblo library goven in the command line.</br>
If you're running the CSL demo OSC synthesis server, you can now open</br>
a shell window and use commands such as,</br>
</br>
&emsp;# Plucked string (amp, pitch, pos)</br>
&emsp;oscsend localhost 54321 /i1/pn fff   0.77 207.67 -0.271&emsp;</br>
&emsp;</br>
&emsp;# FM (dur, amp, pitch, pos) or (dur, amp, c_fr, m_fr, ind, pos)</br>
&emsp;oscsend localhost 54321 /i11/pn ffff  3.0 0.177 207.67 -0.271</br>
&emsp;oscsend localhost 54321 /i12/pn ffff  3.0 0.177 207.6 207.6 0.0 0.0</br>
&emsp;</br>
&emsp;# FM bell</br>
&emsp;oscsend localhost 54321 /i21/pn fffffff  3.0 0.77 107.67 0.5 180.0 120.0 0.0 </br>
</br>
&emsp;# Snd file player (amp, pos)</br>
&emsp;oscsend localhost 54321 /i31/pn ff  3.0 0.0 </br>
&emsp;oscsend localhost 54321 /i32/pn ff  3.0 0.0 </br>
&emsp;</br>
&emsp;# SHARC add-syn - basic version w vibrato</br>
&emsp;oscsend localhost 54321 /i35/pn ffff  3.0 0.77 207.67 -0.271</br>
&emsp;oscsend localhost 54321 /i36/pn ffff  3.0 0.77 207.67 -0.271</br>
&emsp;</br>
&emsp;# SHARC add-syn - basic version w attack chiff</br>
&emsp;oscsend localhost 54321 /i51/pn ffff  3.0 0.77 207.67 -0.271</br>
&emsp;oscsend localhost 54321 /i52/pn ffff  3.0 0.77 207.67 -0.271</br>
&emsp;</br>
&emsp;# Vector-synth SHARC add synth (dur, amp, pitch, pos)</br>
&emsp;# Version with SHARC instruments, i.e., different spectra per-note and straight cross-fade</br>
&emsp;oscsend localhost 54321 /i56/pn ffff  3.0 0.77 144.7 0.0</br>
&emsp;oscsend localhost 54321 /i57/pn ffff  3.0 0.77 144.7 0.0</br>
&emsp;oscsend localhost 54321 /i58/pn ffff  3.0 0.77 144.7 0.0</br>
&emsp;oscsend localhost 54321 /i59/pn ffff  3.0 0.77 144.7 0.0</br>
&emsp;oscsend localhost 54321 /i60/pn ffff  3.0 0.77 144.7 0.0</br>
&emsp;</br>
&emsp;# Vector-synth SHARC add synth (dur, amp, pitch, pos)</br>
&emsp;# Version with SHARC instruments and random-walk cross-fade</br>
&emsp;oscsend localhost 54321 /i62/pn ffff  3.0 0.77 144.7 0.0</br>
&emsp;oscsend localhost 54321 /i63/pn ffff  3.0 0.77 144.7 0.0</br>
&emsp;oscsend localhost 54321 /i64/pn ffff  3.0 0.77 144.7 0.0</br>
</p><hr><h3 id="AbstractandSampledSoundObjects">20 - Abstract and Sampled Sound Objects</h3>Sound Objects in Siren</br>
</br>
Siren's hierarchy of events and functions includes objects that represent sampled sounds. These can be used for synthesis, recording, processing, and playback. The fact that a Siren sound is a function means that it has the semantics of a single-valued function of time. A concrete SampledSound has something in its data instance variable (inherited from Function) that might be a word (16-bit) or floating-point sample array, or a CPointer, meaning that the sound's actual data is held onto by CSL, PortAudio, LibSndFile, or Loris. Since sounds are also events, they can have properties such as sound metadata or control functions.</br>
</br>
There are many instance creation methods in the class SampledSound, including examples to create several kinds of waveforms, frequency sweeps, and impulse trains.</br>
</br>
Examples</br>
</br>
Create a 1-second sine wave sound at a sample rate of 44100 Hz, with 1 channel and the base frequency of 80 Hz.</br>
&emsp;[(SampledSound sineDur: 5 rate: 44100 freq: 80 chans: 1) edit]</br>
</br>
View a swept sine wave</br>
&emsp;[(SampledSound sweepDur: 2.0 rate: 44100 from: 10 to: 100 chans: 1) edit]</br>
</br>
View a pulse train</br>
&emsp;[(SampledSound pulseTrainDur: 5.0 rate: 44100 freq: 200 width: 0.1 chans: 1) edit]</br>
</br>
View a sawtooth waveform (these 2 methods are the same)</br>
&emsp;[SoundView openOn: SampledSound sawtooth]</br>
&emsp;[SampledSound sawtooth edit]</br>
</br>
Read in a sound from a file</br>
&emsp;[(SampledSound fromFile: 'unbelichtet.aiff') edit]</br>
</br>
Save a sound to a file</br>
&emsp;[(SampledSound sweepDur: 5.0 rate: 44100 from: 50 to: 1000 chans: 1) </br>
&emsp;&emsp;&emsp;&emsp;scaleBy: 0.2; storeOnFileNamed: 'sweep.aiff']</br>
&emsp;[(SampledSound fromFile: 'sweep.aiff') edit]</br>
</br>
Load and edit a long-ish sound file</br>
&emsp;[(SampledSound fromFile: 'FourMagicSentences.aiff') edit]</br>
</br>
Manipulating Sound Objects</br>
</br>
Sampled sound objects can be traeated as normal functions, i.e., one can address them as sample arrays and perform all manner of sample arithmetic, as illustrated in the following example, which mixes a sine wave and a sawtooth using low-level sample-accessing messages.</br>
</br>
&emsp;[ | sin saw |</br>
&emsp;sin := SampledSound sineDur: 1.0 rate: 44100 freq: 10 chans: 1.</br>
&emsp;saw := SampledSound sawtoothDur: 1.0 rate: 44100 freq: 100 chans: 1.</br>
&emsp;sin scaleBy: 0.8.</br>
&emsp;saw scaleBy: 0.1.</br>
&emsp;1 to: sin size do:&emsp;&emsp;&emsp;"loop to do verctor math on sound samples"</br>
&emsp;&emsp;[ :index |</br>
&emsp;&emsp;sin at: index put: ((sin at: index) + (saw at: index))].</br>
&emsp;sin edit]</br>
</br>
Class SampledSound also supports basic envelope extraction, as in this example,</br>
</br>
&emsp;[(SampledSound fromFile: 'kombination1a.snd') rmsEnvelope edit]</br>
</br>
As a final example, one can apply a function to a sound as an envelope, as in this block,</br>
</br>
&emsp;[((SampledSound sineDur: 1.0 rate: 44100 freq: 220 chans: 1) </br>
&emsp;&emsp;&emsp;&emsp;scaledByFunction: (ExponentialFunction default)) edit]</br>
</br>
For fancier signal processing, we use the CSL package rather than sample arithmetic with sounds and fnuctions.</br>
</br>
FFTs and Spectra</br>
</br>
There's also an FFT-based spectrum class in Siren, which uses the external interface to the FFTW FFT package. To use it, look at the example methods in the class Spectrum and SpectrumView</br>
</br>
&emsp;[Spectrum sweepExample display]</br>
&emsp;[Spectrum fileExample display]</br>
</br>
For more on sound processing, see the the various *sound* class utility methods, the SoundFile I/O methods, and notes below on the CSL framework in Siren.</br>
</p><hr><h3 id="SoundFilesandStreamingSoundIO">21 - Sound Files and Streaming Sound IO</h3>Sound File I/O</br>
</br>
Siren sound objects can be read from and written to sound files using an external interface to Eric DeCastro's libSndFile library. This supports all popular (and many very obscure) sound file formats.</br>
</br>
Store a swept sine to a file</br>
&emsp;[(SampledSound sweepDur: 2.0 rate: 44100 from: 30 to: 300 chans: 1)</br>
&emsp;&emsp;&emsp;storeOnFileNamed: 'sweep.aiff']</br>
</br>
Look at the file using your favorite sound file editor, or do</br>
&emsp;[(SampledSound fromFile: 'sweep.aiff') edit]</br>
</br>
Read various file formats</br>
&emsp;[(SampledSound fromFile: 'unbelichtet.aiff') edit]</br>
&emsp;[(SampledSound fromFile: 'kombination1a.snd') edit]</br>
</br>
Streaming Sound Record/Playback</br>
</br>
To support real-time streaming sound recording and playback, an external interface is provided to the cross-platform PortAudio library. The singleton instance of PortAudioPort communicates with the external driver. As with the MIDI port, the sound port object loads and maintains a device table. For my system, this is,</br>
</br>
Sound Device Table 2007</br>
&emsp;1: Built-in Microphone 2 in 0 out 44100 Hz</br>
&emsp;2: Built-in Line Input 2 in 0 out 44100 Hz</br>
&emsp;3: Built-in Output 0 in 2 out 44100 Hz</br>
&emsp;4: TASCAM FW-1804 8 in 8 out 96000 Hz</br>
</br>
2020 Sound device table</br>
</br>
Found 6 PortAudio devices</br>
&emsp;&emsp;0: Built-in Output - 0 i 2 o   SR: 44100</br>
&emsp;&emsp;1: Display Audio - 1 i 2 o  (def_in)  SR: 44100</br>
&emsp;&emsp;2: USB audio CODEC - 0 i 2 o   SR: 48000</br>
&emsp;&emsp;3: USB audio CODEC - 1 i 0 o   SR: 48000</br>
&emsp;&emsp;4: BlackHole 16ch - 16 i 16 o   SR: 44100</br>
&emsp;&emsp;5: OrionStudio2017 - 32 i 32 o  (def_out)  SR: 44100</br>
PA_open_p: 2 out, sr 44100 bs 2048 fmt 8</br>
</br>
To play a sound file using the default external utility , use</br>
&emsp;[Sound playFile: 'unbelichtet.aiff']</br>
</br>
(see the method SirenUtility playSoundFile: to change the actual command line,)</br>
</br>
This example plays a 3-second sine wave sweep</br>
&emsp;[PortAudioPort playSweep]</br>
</br>
Same only 20 seconds long</br>
&emsp;[PortAudioPort playSweepLong]</br>
</br>
The class SoundPort is abstract and has two subclasses: PortAudioPort and SmartAudioPort. SmartAudioPort uses call-backs from the C callback into Smalltalk. It works for recording and playback, but is still buggy (clicks a lot); see the class examples.</br>
</p><hr><h3 id="TheSirenGraphicsFramework">22 - The Siren Graphics Framework</h3>The Siren Graphics Framework</br>
</br>
The Siren graphical applications are based on the simple display list graphics framework in the categories MusicUI-DisplayLists and MusicUI-DisplayListViews. This package includes display items such as lines, polygons, curves, text items, and images, hierarchical display lists, and display list views, editors, and controllers. The display list view/controller/editor are MVC components for viewing and manipulating display lists. Simple examples of the display list framework are given below.</br>
</br>
There are several layouts for the zoom/scroll bars; in the default layout, the bars are grouped on the left and bottom of the window. The zoom bars are gray sliders on the outside, and the scroll bars are the usual color and look, and are set inside of the zoom bars. Take a look at the following and use the zoom/scroll bars.</br>
&emsp;[Siren.DisplayList rectangleExample]</br>
</br>
Note that the small button labeled "z" in the upper-left of the window zooms back to 1@1 scale.</br>
</br>
An alternative layout (which I prefer) places the zoom bars on the top and right. look at,</br>
&emsp;[DisplayListView open4SquareOn: (DisplayList rectanglesX: 4000 byY: 4000)]</br>
&emsp;[DisplayListView open4SquareOn: DisplayList randomExample]</br>
</br>
The pop-up menu has many functions that are not implemented in the top-level display list view.</br>
</br>
Display random strings</br>
&emsp;[DisplayList stringExample]</br>
</br>
Display a hierarchical list</br>
&emsp;[DisplayListView exampleHierarchical]</br>
</br>
&emsp;[DisplayList randomExample display]</br>
</br>
There are many more examples in the display item classes, and the display list view hierarchy.</br>
</br>
Layout Managers and Navigator MVC</br>
</br>
The Siren version of "Navigator MVC" framework is based on layout manager objects that can generate display lists from structured objects. This enables, for example, a variety of musical notations. </br>
</br>
LayoutManagers take data structures and generate display lists based on their layout policies. For example, to see a class inheritance hierarchy as an indented list, use an IndentedListLayoutManager as in,</br>
</br>
&emsp; [DisplayListView colorClassListExample]</br>
</br>
(Note that color denotes species in this example.)</br>
</br>
To view the same structure as a tree-like layout, use an IndentedTreeLayoutManager, as in,</br>
</br>
&emsp;[DisplayListView classTreeExample]</br>
</br>
Graphical Forms</br>
</br>
Siren includes a hierarchical dictionary of images for use in musical notations. Execute the following to display the various forms. The method below steps through the form dictionaries and displays them in a window.</br>
</br>
&emsp;[DisplayVisual displayMusicConstants]</br>
</p><hr><h3 id="SirenGUIsandApplicationSupport">23 - Siren GUIs and Application Support</h3>Siren GUI Applications</br>
</br>
Quick tour: http://fastlabinc.com/Siren/Doc/Siren.GUI_2007.html</br>
</br>
Based on the display list view framework and the Navigator layout managers, Siren implements a variety of musical notations. Layout managers serve as the basis for Siren's music notation applications. The basic event-oriented layout manager uses the horizontal axis to denote time (flowing from left to right), as in the next example, which opens a time sequence view on a random event list.</br>
</br>
&emsp;[TimeSequenceView randomExample]</br>
</br>
In the time sequence view, the "note head" signifies the event's voice, not the duration.  Try zooming this view.</br>
</br>
A pitch/time view is an extension of this that uses the vertical dimension to display an event's pitch, as in piano-roll notation; for example, to display a pitch/time view on a 3-stream event list, try,</br>
</br>
&emsp;[PitchTimeView randomExample]</br>
&emsp;[PitchTimeView openOnEventList: (EventList scaleExampleFrom: 48 to: 84 in: 10)]</br>
</br>
In the above example, the note heads denote the events' voices, horizontal blue lines originating at the note heads show the events' lengths, and red vertical lines show the events' amplitudes. To see how this is done, look at class PitchTimeView's various implementation of the itemFor: method.</br>
</br>
Open a pitch/time view on a *very long* 3-stream event list.</br>
</br>
&emsp;[PitchTimeView randomExampleLong]</br>
</br>
A more complete example is Hauer-Steffens notation, which has a clef and staff lines as in common-practise notation.</br>
</br>
&emsp;[HauerSteffensView randomExample]</br>
&emsp;[HauerSteffensView randomSWSSExample]</br>
&emsp;[(EventList scaleExampleFrom: 48 to: 60 in: 3) edit]</br>
</br>
Test panning and zooming these examples.</br>
</br>
Sound View</br>
</br>
The sound view is a simple waveform display. One can scroll, zoom, and edit.</br>
Use the pop-up menu to create sound objects based on a number of standard synthesis methods.</br>
</br>
&emsp;[(SampledSound sweepDur: 3.0 rate: 44100 from: 10 to: 400 chans: 1) edit]</br>
&emsp;[SoundView openOn: (SampledSound fromFile: 'kombination.snd')]</br>
</br>
File Browser Extensions</br>
</br>
Select a sound or score file in the file browser and note the new tab in the file pane. this allows you to play, edit, or remove files easily.</br>
</br>
See also</br>
</br>
&emsp;FunctionViews</br>
&emsp;Loris GUI Examples</br>
&emsp;LPC GUI Examples</br>
</br>
Extending Siren's MVC Framework</br>
</br>
One can of course easily build new notations and new editors with the Siren MVC framework and GUI widget set. New layout managers generally consist of less than 1 page of code, and new controller/editor functions are quite simple to add. Most new tools consist of composite panes that use the simple Siren display widgets as components, and add fancier editor behaviors.</br>
</p><hr><h3 id="UsingtheSirenUtilityPaneandTransports">24 - Using the Siren Utility Pane and Transports</h3>Using the Siren Utility Pane and Transports</br>
</br>
Support classes SirenUtility and SirenSession</br>
</br>
There are two classes with utility and session management methods: SirenUtility and SirenSession.</br>
</br>
SirenUtility is never instantiated, but has class methods for a number of usefiul utility functions related to system configuration (global verbosity flag and search directories). There are special functions for file search (see the section below on this page) and for handling s7 files (see below as well). The SirenUtility class initialization method sets the global logging verbosity level and creates a couple of lists of directories for searching for sound or score files. Users will typically customize this method so that Siren can find their data files.</br>
</br>
SirenSession holds onto the user's persistent data (e.g., sounds and scores) in class-side dictionaries. This means that, by default, every sound or score that you give a name to becomes persistent and is stored in your Smalltalk virtual image. There are special functions for loading these caches from your hard disk, or for flushing them.</br>
</br>
Links to the EventScheduler</br>
</br>
The SirenSession also registers itself as a dependent of the EventScheduler, so it handles event logging and transport functions.</br>
</br>
SirenUtility Panel</br>
</br>
There are two main GUIs for Siren configuration: the Utility and the Transport.</br>
</br>
The Siren utility panel has buttons for configuring and testing MIDI, sound, and OSC I/O, as well as for setting some global values such as the logging verbosity. There are also buttons in this panel for loading and flushing the session data.</br>
</br>
To open the Siren utility view, use the button in the Launcher, or execute</br>
&emsp;[SirenSession openUtility] d</br>
</br>
The left-most buttons in the pane asre for setting up and testing the MIDI and OSC I/O defaults. The 2nd row is for sound I/O cnofiguration.</br>
</br>
SirenTransport Panel</br>
</br>
The other SirenSession class GUI is the transport panel; to open this, hold down <SHIFT> while pressing the Siren utility button in the launcher, or execute,</br>
&emsp;[SirenSession openTransport] d</br>
</br>
The transport has menu buttons along the left for accessing your data (sounds, scores, and voices) and for controlling the EventScheduler. Below are some useful utility messages.</br>
</br>
&emsp;"SirenSession release"</br>
&emsp;"SirenSession instanceCount"</br>
&emsp;"SirenSession allInstances do: [ :ss | ss release]"</br>
&emsp;"EventScheduler instanceCount"</br>
&emsp;"EventScheduler instance"</br>
</br>
SirenUtility file tricks</br>
</br>
The folliowing examples demonstrate the SirenUtility class support for sound/score data. As mentioned above, users can customize the search directories by editing the SirenUtility class initialize method.</br>
</br>
Find a file with the given name in any of the user's sound/score folders</br>
</br>
&emsp;[SirenUtility findFile: 'stp.ev'] p</br>
</br>
Find a directory</br>
</br>
&emsp;[SirenUtility findDir: 'Data' tryHard: false] p</br>
&emsp;[SirenUtility findDir: 'Frameworks' tryHard: true] p</br>
</br>
List all files with the given extension</br>
</br>
&emsp;[SirenUtility findFiles: 'au'] p</br>
&emsp;[SirenUtility findFiles: 'mid'] p</br>
</br>
Create a new s7 folder and ask for the next free of a specific type name in it</br>
</br>
&emsp;[SirenUtility createS7: ((SirenUtility findDir: 'Data/'), 'testing')] d</br>
&emsp;[SirenUtility nextName: 'testing' type: 'aiff' ] p</br>
</br>
SirenSession Storage</br>
&emsp;SirenSession eventLists</br>
&emsp;SirenSession sounds</br>
</br>
Recreate the instance</br>
&emsp;SirenSession refresh</br>
&emsp;SirenSession release</br>
&emsp;SirenSession instance</br>
</p><hr><h3 id="ExternalInterfacesviaDLLCC">25 - External Interfaces via DLLCC</h3>Siren DLLCC External Interfaces</br>
</br>
Siren includes several interfaces between Smalltalk and C to access sound and MIDI I/O in a cross-platform manner. These use the DLLCC package to generate Smalltalk classes whose methods are references to C functions in a dynamic library. </br>
</br>
To compile and load these, you should either down-load the CSL library binaries package from the CSL home page (http://fastlabinc.com/CSL) or else you need to be able to use your platform's C compiler and linker (a Makefile is provided), and to capture the standard output from a VisualWorks virtual machine (normally routed to a console window).</br>
</br>
Load and test the DLLCC External Interfaces</br>
&emsp;LibSndFile - sound file IO in many formats</br>
&emsp;&emsp;[LibSndFileInterface example1: 'unbelichtet.aiff']</br>
&emsp;PortMIDI - cross-platform MIDI API</br>
&emsp;&emsp;[PortMidiInterface testMIDI]</br>
&emsp;PortAudio - cross-platform audio API</br>
&emsp;&emsp;[PortAudioInterface example0]</br>
&emsp;FFTW - Fast Fourier Transform</br>
&emsp;&emsp;[FFTWInterface example] (try this twice)</br>
</br>
Look at each of the interface class defs in MusicIO-External and plug in the directory names for your dynamic libraries. Each of these tests dumps output to the transcript and to the VM's stdout/console.</br>
</br>
Flush all</br>
&emsp;[SirenExternalInterface unload]</br>
</br>
LibSndFile - see the class def for Siren.LibSndFileInterface in category MusicIO-External; tune the lines</br>
</br>
&emsp;&emsp;#(#libraryFiles #('libsndfile.dylib' 'sndfile_lite.dylib'))</br>
&emsp;&emsp;#(#libraryDirectories #('Siren7.5/DLLCC' '/usr/local/lib'))</br>
</br>
This test dumps the first few 100 samples of the test file to the transcript.</br>
&emsp;[LibSndFileInterface example1: 'unbelichtet.aiff'] </br>
&emsp;"LibSndFileInterface unloadLibraries"</br>
</br>
PortMIDI - see the class def for Siren.LibSndFileInterface in category MusicIO-External; tune the lines</br>
</br>
&emsp;&emsp;#(#libraryFiles #('portmidi_lite.dylib' 'portmidi.dylib' 'CoreMIDI'))</br>
&emsp;&emsp;#(#libraryDirectories #('/usr/local/lib' 'Siren7.5/DLLCC' </br>
&emsp;&emsp;&emsp;&emsp;&emsp;'/System/Library/Frameworks/CoreMIDI.framework/Versions/Current'))</br>
</br>
This test prints the return values of a few simple MIDI operations to the transcript.</br>
Look in the standard output of the VM (on the Mac, this means open a console tool) to see the device list that is dumped by the initialize method.</br>
&emsp;[MIDIPort testOpenClose]</br>
&emsp;[PortMidiInterface testMIDI] </br>
&emsp;[MIDIPort testANote]</br>
&emsp;"PortMidiInterface unloadLibraries"</br>
</br>
PortAudio - see the class def for Siren.PortAudioInterface in category MusicIO-External; tune the lines</br>
</br>
&emsp;&emsp;#(#libraryFiles #('portaudio_lite.dylib' 'libportaudio.dylib'))</br>
&emsp;&emsp;#(#libraryDirectories #('Siren7.5/DLLCC' '/usr/local/lib'))</br>
</br>
These tests are progressive, first open/close only, then simple call-backs, then actual data transfer</br>
Look in the standard output of the VM (on the Mac, this means open a console tool) to see the device list that is dumped by the initialize method.</br>
&emsp;[PortAudioInterface example0]</br>
&emsp;[PortAudioInterface example1]</br>
&emsp;[PortAudioPort playSweep]</br>
&emsp;"PortAudioInterface unloadLibraries"</br>
</br>
FFTW - see the class def for Siren.FFTWInterface in category MusicIO-External; tune the lines</br>
</br>
&emsp;&emsp;#(#libraryFiles #('fftw_lite.dylib' 'libfftw3f.a'))</br>
&emsp;&emsp;#(#libraryDirectories #('/usr/local/lib'))</br>
</br>
The basic test creates a sawtooth wave and takes its FFT, displaying the result in a function view. The view also displays the original signal if you hold <SHIFT> down while executing the expression.</br>
</br>
&emsp;[FFTWInterface example]</br>
&emsp;[Spectrum sweepExample display]</br>
&emsp;[Spectrum fileExample display]</br>
</br>
There are more examples of the use of FFTW in the Spectrum class.</br>
</br>
See also the sections below on the SWIG interfaces to CSL and Loris.</br>
</p><hr><h3 id="TestingtheExternalSWIGInterfaces">26 - Testing the External SWIG Interfaces</h3>Loading the SWIG Packages in Siren</br>
</br>
[Obsolete since SWIG no longer Smalltalk - sad]</br>
</br>
There is a Smalltalk back-end to the SWIG interface generator ported by Ian Upright. This allows us to use the SWIG APIs to access CSL and Loris packages from within Siren. If you're new to this, look at the README files in the SWIG example folders, then at the example notes below. See esp. </br>
&emsp;http://commonsmalltalk.wikispaces.com/SWIG+Documentation</br>
and</br>
&emsp;http://commonsmalltalk.wikispaces.com/SwigForVW</br>
</br>
Note that normal Siren uesrs don't need to go into this; you can use the CSL and Loris interfaces (see the workbook section on models below) without having to regenerate the SWIG interfaces.</br>
</br>
Testing the Smalltalk SWIG Interface using Ian Upright's Example code</br>
</br>
Basic SWIG test: shared constants in the API - First you have to go to the example folder (Siren7.5/SWIG_Smalltalk/Examples/smalltalk/constants) and compile the example library, producing a .dll or .a file. The code block below calls the AMLImporter to load a list of .ssi files, creating an external interface and group of classes in the Siren namespace. (Edit your folder name in below.)</br>
</br>
[#( 'ExampleConstants' 'ExampleConstantsConstants' 'ExampleConstantsEmbeddedConstants'</br>
&emsp; 'ExampleConstantsNI' 'ExampleConstantsTest' ) </br>
&emsp;&emsp;do: [:nam |</br>
&emsp;&emsp;&emsp;AMLImporter new</br>
&emsp;&emsp;&emsp;&emsp;baseDirectoryName: 'Siren7.5/SWIG_Smalltalk/Examples/smalltalk/constants/' ;</br>
&emsp;&emsp;&emsp;&emsp;namespace: Smalltalk.Siren ;</br>
&emsp;&emsp;&emsp;&emsp;import: nam]]</br>
</br>
Look at the class def for ExampleConstantsNIExternalInterface and make certain the DLL name and folder are correct; I have to paste in,</br>
&emsp;&emsp;&emsp;#(#libraryFiles #('ExampleConstants.a'))</br>
&emsp;&emsp;&emsp;#(#libraryDirectories #('Siren7.5/SWIG_Smalltalk/Examples/smalltalk/constants'))</br>
</br>
Now test is with (this prints stuff to the transcript)</br>
&emsp;[Siren.ExampleConstantsTest run] d</br>
</br>
Next step: variables in C. Compile the ExampleVariables library as above, then execute the following block.</br>
</br>
["#( 'ExampleVariables' 'ExampleVariablesNI' 'ExampleVariablesTest' 'SwigTypePint' 'SwigTypePPoint' )" </br>
 #( 'ExampleVariablesTest' ) do: [:nam |</br>
AMLImporter new</br>
&emsp;baseDirectoryName: 'Siren7.5/SWIG_Smalltalk/Examples/smalltalk/variables/' ;</br>
&emsp;namespace: Smalltalk.Siren ;</br>
&emsp;import: nam]]</br>
</br>
Look at the class def for ExampleVariablesNIExternalInterface, editing it to fit your environment; then try,</br>
&emsp;[Siren.ExampleVariablesTest run] d&emsp;&emsp;"prints stuff to the transcript"</br>
</br>
Now try loading a C++ class hierarchy and creating some shape objects</br>
</br>
[ #( 'ExampleClassTest' ) do: [:nam |</br>
AMLImporter new</br>
&emsp;baseDirectoryName: 'Siren7.5/SWIG_Smalltalk/Examples/smalltalk/class/' ;</br>
&emsp;namespace: Smalltalk.Siren ;</br>
&emsp;import: nam]]</br>
</br>
Look at the class def for ExampleClassNIExternalInterface</br>
</br>
Siren.ExampleClassTest run&emsp;&emsp;"prints stuff to the transcript" </br>
</p><hr><h3 id="SWIGInterfacestoLorisandCSL">27 - SWIG Interfaces to Loris and CSL</h3>Using Loris and CSL via SWIG</br>
</br>
[Obsolete since SWIG no longer Smalltalk - sad]</br>
</br>
Loris is a sound analysis/resynthesis package written by Kelly Fitz that uses the model of time-reassigned bandwidth-enhanced partial lists to allow one flexible resynthesis control and sound morphing. Siren uses the SWIG-generated interface and glue code to create Smalltalk classes with methods for modeling Loris analyzers and partial lists. To get the current Loris release, see http://sourceforge.net/projects/loris</br>
</br>
To build it from scratch (not necessary unless you change the C++ code), first declare the shared variable for the interface, then load all the SSI files.</br>
</br>
[Siren.Loris defineSharedVariable: #LorisNI</br>
&emsp;private: false</br>
&emsp;constant: false</br>
&emsp;category: 'external'</br>
&emsp;initializer: nil</br>
&emsp;attributes: #( #(#package 'Siren'))] d</br>
</br>
To import the Loris interface (the SSI files generated by swig), execute the following.</br>
</br>
[AMLImporter new</br>
&emsp;baseDirectoryName: 'Siren7.5/SWIG_Loris/';&emsp;&emsp;"Edit your folder name in here"</br>
&emsp;namespace: Smalltalk.Siren.Loris ;&emsp;&emsp;&emsp;&emsp;"put it in its own namespace"</br>
&emsp;import: 'Loris'] d</br>
</br>
Look at the class definition for LorisNIExternalInterface and make certain the DLL or dylib name is right for your platform, and that the path is correct; I paste in the following lines,</br>
</br>
&emsp;&emsp;&emsp;#(#libraryFiles #('loris_smalltalk.dylib'))&emsp;&emsp;&emsp;&emsp;"Edit your DLL name in here"</br>
&emsp;&emsp;&emsp;#(#libraryDirectories #('Siren7.5/SWIG_Loris')) &emsp;&emsp;"Edit your folder name in here"</br>
&emsp;&emsp;&emsp;#(#beVirtual false)</br>
&emsp;&emsp;&emsp;#(#optimizationLevel #full))</br>
</br>
and accept the change. You might want to file in ./Siren7.5/Loris-freeModule.st</br>
</br>
For normal usage, set-up with this</br>
&emsp;[Siren.Loris.Loris initializeModule] d</br>
&emsp;[Siren.Loris.LorisNI] i&emsp;&emsp;&emsp;"inspect the interface if you're interested"</br>
</br>
Test with this (prints the Loris version string)</br>
&emsp;[Siren.Loris.Loris version] p</br>
</br>
Clean up utilities</br>
&emsp;Siren.Loris.Loris freeModule</br>
&emsp;Siren.Loris.LorisNIExternalInterface unloadLibraries</br>
&emsp;Siren.Loris.LorisNIExternalInterface instanceCount</br>
&emsp;Siren.LorisSound instanceCount</br>
&emsp;Siren.LorisSound allInstances</br>
</br>
Using the SWIG Interface to CSL</br>
</br>
The CREATE Signal Library (CSL) is a C++ framework for building digital audio synthesis and processing applications. Siren uses the SWIG-generated CSL interface and glue code together with CSL.dylib to create CSL object networks (DSP flow graphs) from within Smalltalk.</br>
</br>
Get CSL</br>
&emsp;http://FASTLabInc.com/CSL</br>
</br>
The C++ code still has lots of multiple inheritance (i.e., Scalable, Phased, etc.), which makes some problems in the generated (single inheritance) Smalltalk models; I've added some utility messages to UnitGenerator (e.g., setScale: and setOffset:), but these might cause problems if used incorrectly.</br>
</br>
To build it from scratch (not necessary unless you change the C++ code), first declare the shared variable for the interface, then load all the SSI files.</br>
</br>
[Siren.CSL defineSharedVariable: #CslNI</br>
&emsp;private: false</br>
&emsp;constant: false</br>
&emsp;category: 'external'</br>
&emsp;initializer: nil</br>
&emsp;attributes: #( #(#package 'Siren'))] d</br>
</br>
[AMLImporter new</br>
&emsp;baseDirectoryName: 'Siren7.5/SWIG_CSL/';&emsp;&emsp;&emsp;&emsp;&emsp;"Edit your folder name in here"</br>
&emsp;namespace: Smalltalk.Siren.CSL ;</br>
&emsp;import: 'CSL']</br>
</br>
Look at the class definition for LorisNIExternalInterface and make certain the DLL or dylib name is right for your platform, and that the path is correct.</br>
&emsp;&emsp;&emsp;#(#libraryFiles #('CSL_SWIG_wrap.so'))</br>
&emsp;&emsp;&emsp;#(#libraryDirectories #('Siren7.5/SWIG_CSL'))&emsp;&emsp;"Edit your folder name in here"</br>
&emsp;&emsp;&emsp;#(#beVirtual false)</br>
&emsp;&emsp;&emsp;#(#optimizationLevel #full))</br>
</br>
To test CSL, try the following,</br>
</br>
Set-up</br>
&emsp;[Siren.CSL.CSL initializeModule] d</br>
</br>
First test; print a random number</br>
&emsp;[Siren.CSL.CSL fRand&emsp;  ] p</br>
</br>
Test the logging</br>
&emsp;[Siren.CSL.CSL logMsg: 'Testing logging from Smalltalk'] d</br>
</br>
House-keeping</br>
&emsp;[Siren.CSL.CslNI] i</br>
&emsp;Siren.CSL.CSL freeModule</br>
&emsp;Siren.CSL.CslNIExternalInterface unloadLibraries</br>
&emsp;Siren.CSL.CslNIExternalInterface instanceCount</br>
</br>
The CSL IO classes cache the singleton IO object, so you might have to explicitly flush it from time to time</br>
&emsp;[Siren.CSL.IO release]</br>
</p><hr><h3 id="SirenModelsforLorisandCSL">28 - Siren Models for Loris and CSL</h3>Object Models for Loris and CSL</br>
</br>
[Obsolete since SWIG no longer Smalltalk - sad]</br>
</br>
The Siren kernel of the Loris interface is in the classes LirosSound and LirosAnalyzer. The class LorisAnalysisConfiguration represents the variables used by the analyzer.</br>
</br>
Simple Loris tests</br>
</br>
To load a sound file and run it, saving the result as SDIF and opening a display (read this method to see how to use the Loris API)</br>
&emsp;[LorisSound example: '1.2a1.aiff' resolution: 70] db</br>
&emsp;[LorisSound fromSDIF: 'horns1c.sdif']</br>
</br>
Loris Analyzer Configuration</br>
</br>
There is a special class that manages the Loris analyzer settings; it has an editor default Loris analyzer settings (when set to resolution of 70 Hz) are:</br>
&emsp;hopT 0.0142857</br>
&emsp;winWidth 70</br>
&emsp;size 1291</br>
&emsp;BWwid 2000</br>
&emsp;sideLobes 90</br>
&emsp;cropT 0.0142857</br>
&emsp;freqDrift 35</br>
&emsp;freqFloor 70</br>
&emsp;ampFloor -90</br>
</br>
Loris Sound</br>
</br>
LorisSound is a subclass of sound that has before/after versions of a sound and methods for managing the various envelopes and analysis behaviors.</br>
</br>
LorisEditor GUI</br>
</br>
The LorisEditor GUI has 4 main panes: 2 for sound views, a function view, and a spectrum view. Depending on the application, these might be an original and a resynthesized sound (for tuning analysis parameters), or two different sounds (for morphing). The menu bar at the top of the editor view contains items for all the important Loris functions.</br>
</br>
CSL Models in Siren</br>
</br>
The CSL unit generator models are in the Siren.CSL namespace. the CSLGraph class represents an instrument or DSP patch in the same sense that a CSL instrument object does. There are numerous example methods in the CSLGraph class.</br>
</br>
To oest a CSL graph; play a simple note</br>
&emsp;[CSLGraph testSimpleGraph] d</br>
</br>
Test FM</br>
&emsp;[CSLGraph testFM]</br>
</br>
Test processors: filtered noise</br>
&emsp;[CSLGraph testStaticFilter]</br>
&emsp;[CSLGraph testDynamicFilter]</br>
</br>
Play a sound sample</br>
&emsp;[CSLGraph testSoundFile]</br>
</br>
Play 25 oscillators with random-walk freq and position.</br>
&emsp;[CSLGraph testOscillatorBank]</br>
</br>
If you have a MIDI fader box, try the following demo</br>
&emsp;[CSLGraph testMIDIOscillatorBank]</br>
</p><hr><h3 id="PersistencyandSirenDatabases">29 - Persistency and Siren Databases</h3>Data Load/Store and the Paleo Database</br>
</br>
Siren supports several mechanisms for object persistency. First of all, the Smalltalk virtual image facility allows one to save Siren data in a convenient database format (the Smalltalk virtual image snapshot file). The SirenSession class shared dictionaries hold Sounds, EventLists, and Voices in the virtual image, so that they are saved across snapshots. There's a utility method to load the user's sound and score data into the image, and one to flush the shared storage.</br>
</br>
&emsp;[SirenSession loadDemoData]&emsp;&emsp;"load all your data into Smalltalk"</br>
&emsp;[SirenSession openTransport]&emsp;&emsp;"See the sound and score menus"</br>
&emsp;"EventScheduler interrupt; flush"</br>
&emsp;"EventScheduler release"</br>
&emsp;[SirenSession initialize]&emsp;&emsp;&emsp;"flush everything"</br>
</br>
Now use the pop-up menus in the transport view to browse and select sounds, scores, timers, etc.</br>
</br>
Siren Native Format and BOSS</br>
</br>
As described in the sections above, Siren can read and write a variety of standard multimedia file formats. Where we require features not present in other formats we also use several Siren-specific file formats, for example to store sets of envelope functions as breakpoint envelopes in a single file -- Siren's ".env" files supported by the Function class and used by the Loris package.</br>
</br>
Siren also defines a new package file format called ".s7" files. These are folders (named xxx.s7) that contain various kinds of files (sound, SDIF, envelope, LPC data, etc.) that are to be treated as a group. This supports, e.g., versioning of Loris analysis/resynthesis files. The code that implements this format is in the class SirenUtility.</br>
</br>
Paleo SMS (Squeak MinneStore)</br>
</br>
Note: The paleo test data is not included with this release, and the examples below are stale.</br>
</br>
MinneStore is a smalltalk native object-oriented database.</br>
</br>
Load Event Lists from MIDI files</br>
</br>
[&emsp;| num fn el |</br>
&emsp;Cursor wait showWhile: </br>
&emsp;&emsp;[1 to: 100 do: [ :ind |</br>
&emsp;&emsp;&emsp;num := ind asZeroFilledString: 3.</br>
&emsp;&emsp;&emsp;fn := SirenUtility scoreDir, 'Scarlatti/K', num, '.MID'.</br>
&emsp;&emsp;&emsp;(FileDirectory root fileExists: fn)</br>
&emsp;&emsp;&emsp;&emsp;ifTrue: [el := (MIDIFileReader scoreFromFileNamed: fn) asEventList.</br>
&emsp;&emsp;&emsp;&emsp;&emsp;el at: #name put: (''ScarlattiK'', num) asSymbol.</br>
&emsp;&emsp;&emsp;&emsp;&emsp;el at: #composer put: ''Domenico Scarlatti''.</br>
&emsp;&emsp;&emsp;&emsp;&emsp;el at: #instrumentation put: #harpsichord.</br>
&emsp;&emsp;&emsp;&emsp;&emsp;el at: #style put: #Baroque.</br>
&emsp;&emsp;&emsp;&emsp;&emsp;Siren eventLists at: (''ScarlattiK'', num) asSymbol put: el]]]]</br>
</p><hr><h3 id="CRAMApplicationManagement">30 - CRAM Application Management</h3>The CREATE Real-time Applications Manager</br>
</br>
(Obsolete)</br>
</br>
CRAM is a distributed processing environment (DPE) database and management tool. For more information, see http://create.ucsb.edu/CRAM. CRAM assumes the existence of a Postgress-SQL database with network and application tables as described in the documentation. CRAM applications are generally written in C++ or SuperCollider. The CRAM manager is in Smaltalk.</br>
</br>
NodeSocketInterface Examples</br>
</br>
Try pinging the CRAM node manager on the local host.</br>
&emsp;NodeSocketInterface pingExample</br>
&emsp;NodeSocketInterface errorExample</br>
&emsp;NodeSocketInterface nameExample</br>
</br>
Creating and starting a clock service via the CRAM node manager on the local host.</br>
&emsp;NodeSocketInterface createServiceExample</br>
</br>
Try pinging the emergency port of the node manager on the local host.</br>
&emsp;NodeSocketInterface emergencyPingExample</br>
</br>
Restart the node manager</br>
&emsp;NodeSocketInterface emergencyRestartExample</br>
</br>
Try getting the log text of the node manager on the local host.</br>
&emsp;NodeSocketInterface getLogExample</br>
</br>
Try getting the tail of the log text.</br>
&emsp;NodeSocketInterface getLogTailExample</br>
</br>
Try creating and starting 2 clock services.</br>
&emsp;NodeSocketInterface handleServicesExample</br>
</br>
Stop all running services.</br>
&emsp;NodeSocketInterface killServicesExample</br>
</br>
Get the list of service names from the CRAM node manager on the local host.</br>
&emsp;NodeSocketInterface listServicesExample</br>
</br>
Try getting the run-time statistics from the CRAM node manager on the local host.</br>
&emsp;NodeSocketInterface statisticsExample</br>
&emsp;NodeSocketInterface benchmarkExample</br>
&emsp;</br>
Database</br>
</br>
Basic test using PostgresSql -- dump the machines table to the Transcript</br>
&emsp;DPE_Util test0</br>
</br>
Manager GUI</br>
</br>
CRAM.ManagerGUI open</br>
</p><hr><h3 id="MusicalExamples">31 - Musical Examples</h3>Extended Siren Examples</br>
</br>
There are a number of additional files with example code from my compositions</br>
See the files in the StaleCode folder of the Siren 7.5 release, especially MusicApps-Pieces.st.</br>
</br>
There is also a 15-minute sampler/tour of my music and the tools used to make it (almost all of them in Smalltalk) on my label's web site at</br>
&emsp;http://HeavenEverywhere.com/RitualAndMemory/Tour</br>
</br>
Tools Used for Individual Pieces</br>
</br>
Requiem Aeternam dona Eis (1985-4): DoubleTalk PetriNet simulation generated score files for cmusic.</br>
</br>
Day (1986-7): EventGenerators + interactive interfaces for simlpe MIDI sequencing.</br>
</br>
Kombination XI (1988-90): TrTree-based speech editors and prosody morphing.</br>
</br>
All Gates are Open (1991-3): Vocoder scripting in Makefiles generated from a speech database.</br>
</br>
Sensing/Speaking Space (1999): Segmented phonemes in 8S speech database used for speaker textures generated by SuperCollider.</br>
</br>
Four Magic Sentences (2000): as above, + 12-tone rows as pitch classes.</br>
</br>
Leur Songe de la Paix (2002-3): 8S database + drone lists + Morse code layer.</br>
</br>
Eternal Dream (2003-5): Percussion event generators via sample libraries.</br>
</br>
Jerusalem's Secrets (2005-6): EventGenerators for sample patterns.</br>
</br>
Ora penso invece che il mondo... (2006): Serial methods dumped via MIDI to Sibelius notation package for (human) string quartet.</br>
</br>
These last 4 items are the movements of "Secrets, Dreams, Faith and Wonder" (https://vimeo.com/92867679)</br>
</br>
Works in Progress: CSL/Loris in event lists</br>
</br>
----------</br>
</br>
SleepingSword examples with CSL OSC and Kontakt MIDI servers - start a few of these running...</br>
</br>
Add these to the do-it menu in the launcher</br>
&emsp;Siren.ClusterEditor open</br>
&emsp;Siren.ClusterEditor openWithSpec: #buttonSpec</br>
</br>
</br>
&emsp;OSCVoice stringExample: 1 to: 2 </br>
&emsp;OSCVoice sndExample3 </br>
&emsp;"OSCVoice fmExample5"</br>
&emsp;OSCVoice vxFadeExample1: 8 </br>
</br>
&emsp;MIDIVoice randomWalk: 100 pitch: 96 dur: 0.11 amp: #ppp chan: 1. </br>
&emsp;MIDIVoice randomWalk: 100 pitch: 84 dur: 0.12 amp: 6 chan: 2. </br>
&emsp;MIDIVoice randomWalk: 100 pitch: 66 dur: 0.08 amp: 40 chan: 3. </br>
&emsp;"Ostinato trillExample"</br>
</br>
&emsp;ClusterEditor open</br>
</br>
</p><hr><h3 id="TheSirenStartupDemoScript">32 - The Siren Startup Demo Script</h3>Your Basic Siren Demo Script</br>
</br>
To use this demo script, read through the text selecting the blocks enclosed in square brackets. The single character after the close-square-bracket (d,p,  i, or db) denotes whether you should "do," "print," "inspect," or "debug" the block. (Typically, CMD-D means do-it, CMD-P means print-it, and CMD-I means inspect-it.) To look at the code for the complex examples below, simply "debug-it" and single-step into the demo method.</br>
</br>
For the function and event list examples below, note that the "open" method edits the receiver by default; if you hold down <SHIFT> while executing it, it will play the receiver, and if you hold down <CTRL> is will inspect the receiver.</br>
</br>
If you're new to reading Smalltalk, look at the workbook section on "Learning to Read Smalltalk." If you're setting up Siren for the first time, see the section above on "Siren Set-up and Testing" and make certain you know how to use the Siren Utility panel and the Siren Transport view.</br>
</br>
Set-up</br>
</br>
Configure and test the MIDI and sound I/O drivers using the utility panel.</br>
</br>
&emsp;[SirenSession openUtility] d</br>
</br>
Load the test data with the "Load All" button in the utility pane.</br>
You can browse the test data with the left-side menu buttons in the transport panel, do,</br>
</br>
&emsp;[SirenSession openTransport] d</br>
</br>
See also the section above on "Siren Set-up."</br>
</br>
MusicMagnitudes</br>
</br>
Print these to see what kinds of music magnitude representations and operations are supported.</br>
</br>
&emsp;[440 Hz asSymbol] p&emsp;&emsp;&emsp;"--> 'a3' pitch"</br>
&emsp;[(1/4 beat) asMsec] p&emsp;&emsp;"--> 250 msec"</br>
&emsp;[#mf ampl asMIDI] p&emsp;&emsp;"--> 70 vel"</br>
&emsp;[-16 dB asRatio value] p&emsp;&emsp;"--> 0.158489"</br>
</br>
&emsp;['a4' pitch asMIDI] p</br>
&emsp;[('a4' pitch + 100 Hz) asMIDI] p</br>
&emsp;[('a4' pitch + 100 Hz) asFracMIDI] p</br>
&emsp;['mp' ampl + 3 dB] p</br>
&emsp;[('mp' ampl + 3 dB) asMIDI] p</br>
&emsp;[(1/2 beat) + 100 msec] p</br>
</br>
Pitch expressions ("N" is short-hand for PitchClass)</br>
</br>
&emsp;[N C sharp sharp] p</br>
&emsp;[N C augmentedFourth] p</br>
&emsp;[N C diminishedThirteenth] p</br>
&emsp;[N do flat intervalBetween: N sol] p</br>
&emsp;[PitchClass D flat melodicMinorScale notes] p</br>
&emsp;[(PitchClassChord new fromString: 'C aug9 dim5') notes] p</br>
&emsp;[(HungarianMinor root: N fa) asPitchesInOctave: 2] p</br>
</br>
Event Creation Messages</br>
</br>
Create a `generic' event using a class instance creation message.</br>
</br>
&emsp;MusicEvent duration: 1/4 pitch: 'c3' ampl: 'mf'</br>
</br>
Create one with added properties.</br>
</br>
&emsp;(MusicEvent dur: 1/4 pitch: 'c3') color: #green; accent: #sfz</br>
</br>
Terse format: concatenation (with ',') of music magnitudes</br>
</br>
&emsp;[440 Hz, (1/4 beat), 44 dB] i</br>
&emsp;(#c4 pitch, 0.21 sec, 64 velocity) voice: IOVoice default</br>
</br>
Event Lists</br>
</br>
Verbose form using a class instance creation message; </br>
a chord is simply a set of events at the same time.</br>
</br>
&emsp;(EventList newNamed: #Chord1)</br>
&emsp;&emsp;add: ((1/2  beat), 'd3'  pitch,  'mf' ampl)  at: 0;</br>
&emsp;&emsp;add: ((1/2  beat), 'fs3'  pitch, 'mf' ampl)  at: 0;</br>
&emsp;&emsp;add: ((1/2  beat), 'a4'   pitch, 'mf' ampl)  at: 0</br>
</br>
Play a scale created with a class message.</br>
</br>
&emsp;[(EventList scaleFrom: 48 to: 60 in: 3000) open] d</br>
</br>
Create 64 random events with parameters in the given ranges, play it on the default output voice, or edit it.</br>
</br>
&emsp;[(EventList randomExample: 64 &emsp;&emsp;&emsp;"make 64 notes"</br>
&emsp;&emsp;from: ((#duration: -> (50 to: 200)),&emsp;&emsp;"duration range in msec"</br>
&emsp;&emsp;&emsp;&emsp;(#pitch: -> (36 to: 60)),&emsp;&emsp;&emsp;"pitch range in MIDI keys"</br>
&emsp;&emsp;&emsp;&emsp;(#ampl: -> (48 to: 120)),&emsp;&emsp;"amplitude range in MIDI velocities"</br>
&emsp;&emsp;&emsp;&emsp;(#voice: -> (1 to: 1)))&emsp;&emsp;&emsp;"play all on voice 1"</br>
&emsp;&emsp;) open] d</br>
</br>
Create an event list of 20 notes with semi-random values and play it on a MIDI output voice.</br>
</br>
&emsp;[(EventList randomExample: 20) playOn: MIDIVoice default] d</br>
</br>
Event lists don't have to have pitches at all, as in the word,</br>
</br>
&emsp;[EventList named: 'phrase1'  </br>
&emsp;&emsp;fromSelectors: #(duration: loudness: phoneme:)&emsp;&emsp;&emsp;"3 parameters"</br>
&emsp;&emsp;values: (Array with: #(595 545 545 540 570 800 540) &emsp;"3 value arrays"</br>
&emsp;&emsp;&emsp;&emsp;&emsp;with: #(0.8 0.4 0.5 0.3 0.2 0.7 0.1) </br>
&emsp;&emsp;&emsp;&emsp;&emsp;with: #(#dun #kel #kam #mer #ge #sprae #che)).</br>
&emsp;(EventList named: 'phrase1') inspect]</br>
</br>
Play two-voice "counterpoint" on the note list score file voices.</br>
</br>
&emsp;[ | vox list |</br>
&emsp;vox := CsoundVoice onFileNamed: 'test.cs'.</br>
&emsp;list := (EventList newNamed: #pRand)</br>
&emsp;&emsp;&emsp;addAll: (EventList randomExample: 20);</br>
&emsp;&emsp;&emsp;addAll: (EventList randomExample: 20).</br>
&emsp;vox play: list.</br>
&emsp;vox close.</br>
&emsp;(Filename named: 'test.cs') edit] d</br>
</br>
Here's another example of creating a simple melody with a terse format</br>
</br>
&emsp;[(EventList named: 'melody'  </br>
&emsp;&emsp;fromSelectors: #(pitch: duration: ampl:)</br>
&emsp;&emsp;values: (Array with: #(c d e f g) </br>
&emsp;&emsp;&emsp;&emsp;&emsp;with: #(4 8 8 4 4) reciprocal</br>
&emsp;&emsp;&emsp;&emsp;&emsp;with: #(1))) open] d</br>
</br>
You can also create event lists with snippets of code such as the following whole-tone scale.</br>
</br>
&emsp;[ | elist |</br>
&emsp;elist := EventList newAnonymous.</br>
&emsp;1 to: 12 do:</br>
&emsp;&emsp;[ :index |</br>
&emsp;&emsp;elist add: (1/4  beat, (index * 2 + 36) key,  'mf' ampl)].</br>
&emsp;elist open ] d</br>
</br>
Event lists can also be nested into arbitrary structures, as in the following group of four sub-groups</br>
</br>
&emsp;[ (EventList newNamed: 'Hierarchical/4Groups')</br>
&emsp;&emsp;add: (EventList randomExample: 8 </br>
&emsp;&emsp;&emsp;from: ((#duration: -> (60 to: 120)), (#pitch: -> (36 to: 40)), (#ampl: -> #(110)))) at: 0;</br>
&emsp;&emsp;add: (EventList randomExample: 8 </br>
&emsp;&emsp;&emsp;from: ((#duration: -> (60 to: 120)), (#pitch: -> (40 to: 44)), (#ampl: -> #(100)))) at: 1;</br>
&emsp;&emsp;add: (EventList randomExample: 8 </br>
&emsp;&emsp;&emsp;from: ((#duration: -> (60 to: 120)), (#pitch: -> (44 to: 48)), (#ampl: -> #(80)))) at: 2;</br>
&emsp;&emsp;add: (EventList randomExample: 8</br>
&emsp;&emsp;&emsp;from: ((#duration: -> (60 to: 120)), (#pitch: -> (48 to: 52)), (#ampl: -> #(70)))) at: 3;</br>
&emsp;&emsp;open ] d</br>
</br>
Smalltalk methods can also process event lists, as in this code to increase the durations of the last notes in each of the groups from the previous example.</br>
</br>
&emsp;[ (EventList named: 'Hierarchical/4Groups') eventsDo: </br>
&emsp;&emsp;[ :sublist | | evnt |&emsp;"Remember: this is hierarchical, to the events are the sub-groups"</br>
&emsp;&emsp;evnt := sublist events last event.&emsp;&emsp;"get the first note of each group"</br>
&emsp;&emsp;evnt duration: evnt duration * 8].&emsp;&emsp;"multiply the duration by 4"</br>
&emsp;(EventList named: 'Hierarchical/4Groups') open ] d</br>
</br>
...or the following to take the scale and make it slow down</br>
</br>
&emsp;[ | elist |</br>
&emsp;elist := EventList scaleFrom: 60 to: 36 in: 2.5. </br>
&emsp;1 to: elist size do: </br>
&emsp;&emsp;[ :index | | assoc |</br>
&emsp;&emsp;assoc := elist events at: index.</br>
&emsp;&emsp;assoc key: (assoc key * (1 + (index / elist events size)))].</br>
&emsp;elist open ] d</br>
</br>
Storage and Persistency</br>
</br>
&emsp;"SirenSession eventList: 'piece1/mvmnt1/part1' put: EventList new"</br>
&emsp;"SirenSession eventList: 'piece1/mvmnt1/part1'"</br>
</br>
Siren Scheduler</br>
</br>
Reset</br>
</br>
&emsp;[EventScheduler initialize]</br>
</br>
Here's how to use the event scheduler explicitly.</br>
</br>
&emsp;[EventScheduler instance addClient: (EventList randomExample: 20) in: (500 msec).</br>
&emsp;EventScheduler instance run] d</br>
</br>
Flush and close down the scheduler</br>
</br>
&emsp;[EventScheduler instance interrupt; flush] d</br>
</br>
Action events have arbitrary blocks of Smalltalk code as their "actions." This example creates a list of action events that flash random screen rectangles.</br>
</br>
&emsp;[ActionEvent playExample] d</br>
</br>
Complex Multimedia Example</br>
</br>
&emsp;[ | el |</br>
&emsp;el := (Cloud  dur: 6&emsp;&emsp;&emsp;&emsp;"Create a 6-second stochastic cloud"</br>
&emsp;&emsp;pitch: (48 to: 60)&emsp;&emsp;&emsp;"choose pitches in this range"</br>
&emsp;&emsp;ampl: (40 to: 70) &emsp;&emsp;&emsp;"choose amplitudes in this range"</br>
&emsp;&emsp;voice: #(1)&emsp;&emsp;&emsp;&emsp;"leave the 1 nil for now"</br>
&emsp;&emsp;density: 5) eventList.&emsp;&emsp;"play 5 notes per sec. and get the events"</br>
&emsp;1 to: el events size do:&emsp;&emsp;&emsp;"Now plug different voices in to the events"</br>
&emsp;&emsp;[ :ind | &emsp;&emsp;&emsp;&emsp;&emsp;"ind is the counter"</br>
&emsp;&emsp;(el events at: ind) event voice: </br>
&emsp;&emsp;&emsp;(ind odd &emsp;&emsp;&emsp;&emsp;"alternate between two voices"</br>
&emsp;&emsp;&emsp;&emsp;ifTrue: [MIDIVoice default] </br>
&emsp;&emsp;&emsp;&emsp;ifFalse: [OSCVoice default])].</br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"add some animation events"</br>
&emsp;el addAll: ActionEvent listExample.</br>
&emsp;el open] d&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"and play the merged event list"</br>
</br>
Functions and Control</br>
</br>
If you like thicker function plots, do this,</br>
</br>
&emsp;[FunctionView lineWidth: 2]</br>
</br>
Basic ramp up/down (linear and exponential flavors)</br>
</br>
&emsp;[(LinearFunction from: #((0 0) (0.5 1) (1 0))) at: 0.25] p</br>
&emsp;[(ExponentialFunction from: #((0 0 5) (0.5 1 -5) (1 0))) at: 0.25 ] p</br>
</br>
ADSR-like envelopes</br>
</br>
&emsp;[(LinearFunction from: #((0 0) (0.1 1) (0.16 0.7) (0.8 0.4) (1 0))) edit]</br>
&emsp;[(ExponentialFunction from: #((0 0 5) (0.02 1 -25) (0.8 0.25 -2) (1 0))) edit]</br>
</br>
Open a view with a linear envelope, an exponential envelope, a spline curve, and a sum-of-sines function</br>
</br>
&emsp;[FunctionView multiFunctionExample]</br>
</br>
One can apply a function to any property of an event list, as in the example below, which makes a crescendo/decrescendo using an exponential triangle function.</br>
</br>
&emsp;[ | list fcn |</br>
&emsp;list := EventList newNamed: #test3.</br>
&emsp;(0 to: 4000 by: 100) do: &emsp;&emsp;"4 seconds, 10 notes per second"</br>
&emsp;&emsp;&emsp;[ :index |&emsp;&emsp;&emsp;"add the same note"</br>
&emsp;&emsp;&emsp;list add: (MusicEvent dur: 100 pitch: 36 ampl: 120) at: index].</br>
&emsp;fcn := ExponentialFunction from: #((0 0.05 2) (0.5 1 -2) (1 0.05)).</br>
&emsp;list applyFunction: fcn to: #loudness.</br>
&emsp;list inspect] d</br>
</br>
Send function data values out as regular OSC messages</br>
</br>
&emsp;[OSCVoice functionExample] db</br>
</br>
Load a SHARC sample and create a wave table from it.</br>
</br>
&emsp;[(Function from: (((SHARCInstrument fromDir: 'tuba') samples at: #c3) asWavetable: 1024)) edit: 1024] d</br>
</br>
EventGenerators</br>
</br>
A cluster is the simplest event generator.</br>
</br>
&emsp;[(Cluster  dur: 2.0</br>
&emsp;&emsp;pitchSet: #(48 50 52 54 56)</br>
&emsp;&emsp;ampl: 50</br>
&emsp;&emsp;voice: 1) open] d</br>
</br>
Chord object can give you an event list.</br>
</br>
&emsp;[((Chord majorTetradOn: 'f2' inversion: 0) duration: 1.0) open] d</br>
</br>
Create and play a simple drum roll--another 1-D event generator.</br>
</br>
&emsp;[((Roll length: 2000 rhythm: 50 note: 60) ampl: 80) open] d</br>
</br>
Create and edit a low 6 second stochastic cloud with 5 events per second.</br>
</br>
&emsp;[ | c |</br>
&emsp;c := (Cloud dur: 6&emsp;&emsp;&emsp;"lasts 6 sec."</br>
&emsp;&emsp;pitch: (48 to: 60)  &emsp;&emsp;"with pitches in this range"</br>
&emsp;&emsp;ampl: (80 to: 120) &emsp;&emsp;"and amplitudes in this range"</br>
&emsp;&emsp;voice: (1 to: 1)&emsp;&emsp;&emsp;"select from these voices"</br>
&emsp;&emsp;density: 5) eventList.&emsp;"play 5 notes per sec. and get the event list"</br>
&emsp;c open] d</br>
</br>
Play a 6-second cloud that goes from low to high and soft to loud.</br>
</br>
&emsp;[(DynamicCloud  dur: 6  </br>
&emsp;&emsp;pitch: #((30 to: 44) (50 to: 50))&emsp;"given starting and ending selection ranges"</br>
&emsp;&emsp;ampl: #((20 to: 40) (90 to: 120))</br>
&emsp;&emsp;voice: (1 to: 4)</br>
&emsp;&emsp;density: 15)  open] d</br>
</br>
Select notes from a given scale</br>
</br>
&emsp;[(SelectionCloud dur: 4  </br>
&emsp;&emsp;pitch: ((NeapolitanMinor root: N do) asPitchesInOctave: 4)</br>
&emsp;&emsp;ampl: #(80 40 120)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 12) open] d</br>
</br>
Play a selection cloud that makes a transition from one triad to another.</br>
</br>
&emsp;[(DynamicSelectionCloud dur: 6</br>
&emsp;&emsp;pitch: #( #(48 50 52) #(72 74 76) )&emsp;"starting and ending pitch sets"</br>
&emsp;&emsp;ampl: #(60 80 120)</br>
&emsp;&emsp;voice: #(1)</br>
&emsp;&emsp;density: 12) open] d</br>
</br>
The extended DynamicSelectionCloud uses a multi-part pitch set  of the format (time -> chord) (time -> chord) ... as in the following example.</br>
</br>
&emsp;[ | score chords list |&emsp;&emsp;&emsp;"generate the tetrads from the selected scale; scramble the order"</br>
&emsp;chords := ((NeapolitanMinor root: N do) generateChordsPoly: 4 inOctave: 2) scrambled.</br>
&emsp;list :=  OrderedCollection new.</br>
&emsp;1 to: 7 do:</br>
&emsp;&emsp;[ :ind |&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"shift every other one up 2 octaves"</br>
&emsp;&emsp;ind even ifTrue: [list add: ((ind - 1) * 3 -> ((chords at: ind) collect: [ :no | no + 24]))]</br>
&emsp;&emsp;&emsp;ifFalse: [list add: ((ind - 1) * 3 -> (chords at: ind))]].</br>
&emsp;score := (ExtDynamicSelectionCloud dur: 8&emsp;"now make a cloud from these"</br>
&emsp;&emsp;pitch: list</br>
&emsp;&emsp;ampl: 60</br>
&emsp;&emsp;voice: nil</br>
&emsp;&emsp;density: 10) eventList.</br>
&emsp;score eventsDo: [ :ev |&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"plug in the properties for FM"</br>
&emsp;&emsp;ev inst: '/i1/pn'.</br>
&emsp;&emsp;ev modIndex: 2.0.</br>
&emsp;&emsp;ev ratio: 1.02.</br>
&emsp;&emsp;ev pos: 0.0].</br>
&emsp;SirenSession eventList: 'EvGens/dsCloud1' put: score.</br>
&emsp;score open] d</br>
</br>
Mark Lentczner's bell peals ring the changes.</br>
</br>
&emsp;[(Peal upon: #(60 65 68 72)) eventList open] d</br>
</br>
EventModifiers</br>
</br>
One can apply functions to the properties of event lists, as in the following example, which creates a drum roll and applies a decrescendo modifier (fcn goes from 0 to 1) to it.</br>
</br>
&emsp;[ | roll decresc |</br>
&emsp;roll := ((Roll length: 3000 rhythm: 150 note: 60) ampl: 120) eventList.</br>
&emsp;decresc := Swell new function: (ExponentialFunction from: #((0 1 4) (1 0))).</br>
&emsp;decresc applyTo: roll.</br>
&emsp;roll open]</br>
</br>
MIDI Control</br>
</br>
Open MIDI, play notes based on the mouse position (x --> dur; y --> pitch) until mouse down.</br>
</br>
&emsp;[MIDIPort testMouseMIDI] d</br>
</br>
Demonstrate program change by setting up an organ instrument to play on.</br>
</br>
&emsp;[MIDIPort testProgramChange] d</br>
</br>
Down-load a general MIDI patch for a 16-voice percussion ensemble.</br>
</br>
&emsp;[MIDIPort setupTunedPercussion. MIDIPort testAScale] d</br>
</br>
Reset the GM map (removed, see old code file-ins)</br>
</br>
&emsp;[MIDIPort resetEnsemble]</br>
</br>
Demonstrate control commands by playing a note and making a crescendo with the volume pedal.</br>
</br>
&emsp;[MIDIPort testControlContinuous] d</br>
</br>
Demonstrate pitch-bend by playing two notes and bending them.</br>
</br>
&emsp;[MIDIPort testBend] d</br>
</br>
ANO</br>
</br>
&emsp;[MIDIPort allNotesOff]</br>
</br>
Close down and clean up.</br>
</br>
&emsp;[MIDIPort cleanUp]</br>
</br>
Voices and I/O</br>
</br>
&emsp;[CsoundVoice randomExampleToFileAndEdit]</br>
&emsp;[SuperColliderVoice randomExampleToFileAndEdit]</br>
</br>
&emsp;[(EventList randomExample: 20) playOn: MIDIVoice default]</br>
&emsp;[OSCVoice midiScaleExample]</br>
</br>
These use the CSL OSC servers</br>
</br>
&emsp;[OSCVoice fmExample1]</br>
&emsp;[OSCVoice sndExample1]</br>
</br>
These examples loop endlessly, so you have to interrupt or flush the scheduler to stop them</br>
</br>
&emsp;[OSCVoice fmExample2. &emsp;&emsp;5 wait.</br>
&emsp;OSCVoice sndExample2.&emsp;&emsp;5 wait.</br>
&emsp;OSCVoice fmExample4]</br>
&emsp;[EventScheduler flush]</br>
</br>
As an example that mixes styles, the following expression plays a long low FM note and then uses Siren function objects to send continuous controls to make the note glissando down and pan from left to right.</br>
</br>
&emsp;[OSCVoice fmExample3]</br>
</br>
The Siren Graphics Framework</br>
</br>
Display rectangles in a display list view -- test zoom and scroll.</br>
</br>
&emsp;[DisplayList rectangleExample]</br>
</br>
An alternative layout (which I prefer) places the zoom bars on the top and right. look at,</br>
</br>
&emsp;[DisplayListView open4SquareOn: (DisplayList rectanglesX: 2000 byY: 2000)]</br>
</br>
Display random strings</br>
</br>
&emsp;[DisplayList stringExample]</br>
</br>
Show the result of the IndentedListLayoutManager</br>
</br>
&emsp;[DisplayListView colorClassListExample]</br>
&emsp;[DisplayListView classTreeExample]</br>
</br>
Music Notations</br>
</br>
Open a sequence view on a random event list.</br>
</br>
&emsp;[TimeSequenceView randomExample] d</br>
</br>
Try the picth-time layout</br>
</br>
&emsp;[PitchTimeView randomExample] d</br>
&emsp;[PitchTimeView openOnEventList: (EventList scaleExampleFrom: 48 to: 84 in: 5)] d</br>
</br>
Open a pitch/time view on a *very long* 3-stream event list.</br>
</br>
&emsp;[PitchTimeView randomExampleLong] d</br>
</br>
A more complete example is Hauer-Steffens notation, which has a clef and staff lines as in common-practise </br>
notation.</br>
&emsp;[HauerSteffensView randomExample] d</br>
&emsp;[(EventList scaleFrom: 40 to: 66 in: 5) edit] d</br>
</br>
Sound Views</br>
</br>
Create and view some example sounds</br>
</br>
&emsp;[SoundView openOn: SampledSound sawtooth] d</br>
&emsp;[(SampledSound sweepDur: 10.0 rate: 44100 from: 10 to: 400 chans: 1) edit] d</br>
</br>
Read in a sound from a file</br>
&emsp;[(SampledSound fromFile: 'unbelichtet.aiff') edit] d</br>
</br>
Now try the external interface examples, then the SWIG Loris and CSL APIs.</br>
</br>
Create a swept sine wave and take its fft.</br>
</br>
&emsp;[Spectrum sweepExample display] d</br>
</br>
Read a file (T'ang dynasty speech) and show the spectrogram</br>
</br>
&emsp;[Spectrum fileExample display] db</br>
</br>
Low-level sample processing: sum a sine and a sawtooth</br>
</br>
&emsp;[ | sin saw |</br>
&emsp;sin := SampledSound sineDur: 1.0 rate: 44100 freq: 10 chans: 1.</br>
&emsp;saw := SampledSound sawtoothDur: 1.0 rate: 44100 freq: 100 chans: 1.</br>
&emsp;sin scaleBy: 0.8.</br>
&emsp;saw scaleBy: 0.1.</br>
&emsp;1 to: sin size do:&emsp;&emsp;&emsp;"loop to do vector math on sound samples"</br>
&emsp;&emsp;[ :index |</br>
&emsp;&emsp;sin at: index put: ((sin at: index) + (saw at: index))].</br>
&emsp;sin edit] d</br>
</br>
As a final example, one can apply a function to a sound as an envelope, as in this block,</br>
</br>
&emsp;[((SampledSound sineDur: 1.0 rate: 44100 freq: 220 chans: 1) </br>
&emsp;&emsp;&emsp;&emsp;scaledByFunction: (ExponentialFunction default)) edit] d</br>
</br>
Using the Loris Interface and Tools</br>
</br>
For normal usage, set-up with this</br>
</br>
&emsp;[Siren.Loris.Loris initializeModule] d</br>
</br>
Test with this (prints the Loris version string)</br>
</br>
&emsp;[Siren.Loris.Loris version] p</br>
</br>
To load a sound file and run it, saving the result as SDIF and opening a display (read this method to see how to use the Loris API)</br>
</br>
&emsp;[LorisSound example: '1.2a1.aiff' resolution: 70] db</br>
&emsp;[LorisSound fromSDIF: 'horns1c.sdif'] d</br>
</br>
Using the CSL Models</br>
</br>
Set-up</br>
</br>
&emsp;[Siren.CSL.CSL initializeModule] d</br>
</br>
First test; print a random number</br>
</br>
&emsp;[Siren.CSL.CSL fRand ] p</br>
</br>
To oest a CSL graph; play a simple note</br>
</br>
&emsp;[CSLGraph testSimpleGraph] d</br>
</br>
Test FM</br>
</br>
&emsp;[CSLGraph testFM]</br>
</br>
Test processors: filtered noise</br>
</br>
&emsp;[CSLGraph testStaticFilter]</br>
&emsp;[CSLGraph testDynamicFilter]</br>
</br>
Play a sound sample</br>
</br>
&emsp;[CSLGraph testSoundFile]</br>
</br>
Play 25 oscillators with random-walk freq and position.</br>
</br>
&emsp;[CSLGraph testOscillatorBank]</br>
</br>
If you have a MIDI fader box, try the following demo</br>
</br>
&emsp;[CSLGraph testMIDIOscillatorBank]</br>
</p><hr><h3 id="BuildingSireninVisualWorks9">33 - Building Siren in VisualWorks 9</h3>Building a Siren Image in VisualWorks 9.0</br>
</br>
To load Siren into a VisualWorks 9.0 virtual image, follow these steps.</br>
</br>
Start VW 9.0</br>
&emsp;Load your favorite parcels (AT tools, DB, etc.)</br>
&emsp;Siren requires the following packages:</br>
&emsp;&emsp;Store/PostgreSQL, DLLCC, BOSS, OldBrowsers (from vw 8.0)</br>
&emsp;Load Siren9.0.pcl</br>
&emsp;It should automatically do the next 2 steps, see the Transcript.</br>
&emsp;File in the MusicConstants.st file</br>
 &emsp;&emsp;['MusicConstants.st' asFilename fileIn]</br>
</br>
&emsp;Now use the Page/load_all menu item to load the workbook contents from the BOSS file Workbook9.0.bos</br>
&emsp;&emsp;[ListWorkBook open]</br>
</br>
By-hand init (see these methods for site tuning)</br>
&emsp;Siren.SoundFile initialize</br>
&emsp;Siren.SirenUtility initialize (or SirenUtility initializeSirenSTP)</br>
</br>
Load optional L&F hacks (in PostBuild)</br>
&emsp;Left-hand scroll bars - left-scroll-bar.st</br>
&emsp;Custom colors - WidgetPolicy class-initializeDefaultGenericColors.st</br>
</br>
See the appropriate Workbook pages for the following subsystems</br>
</br>
&emsp;SirenUtility initialize. SirenSession initialize</br>
</br>
Load and test the DLLCC External Interfaces (see the C makefiles and interface class defs)</br>
&emsp;LibSndFile - [LibSndFileInterface example1: 'unbelichtet.aiff']</br>
&emsp;PortMIDI - [PortMidiInterface testMIDI]</br>
&emsp;FFTW - [FFTWInterface example]</br>
&emsp;PortAudio - [PortAudioInterface example1]</br>
</br>
Test the OSC I/O (assumes some OSC client)</br>
&emsp;OSCVoice midiScaleExample</br>
</br>
Load and test the SWIG Interfaces</br>
&emsp;CSL </br>
&emsp;&emsp;Siren.CSL.CSL initializeModule</br>
&emsp;&emsp;CSLGraph testSimpleGraph</br>
&emsp;Loris</br>
&emsp;&emsp;Siren.Loris.Loris initializeModule</br>
&emsp;&emsp;Siren.Loris.Loris version</br>
&emsp;&emsp;See examples in LorisSound</br>
</br>
Set up a new changelist and make a snapshot...</br>
</br>
To use the DLLCC-based external interfaces for MIDI and Audio IO and accelerated FFT, copy the files in DLLCC/Libs into /usr/local/lib (on a Mac).</br>
</br>
-----------------</br>
</br>
Basic testing - see the demo script for the basic tests</br>
&emsp;Events and EventLists</br>
&emsp;Displays</br>
</br>
External UIs - some of these print to the Transcript, and some to the stdout as well</br>
</br>
FFTWInterface example&emsp;&emsp;&emsp;&emsp;"works the 2nd time"</br>
LibSndFileInterface example1: 'unbelichtet.aiff' </br>
PortAudioInterface example0</br>
PortMidiInterface example1</br>
PortMidiInterface allInstances</br>
</br>
Harder tests</br>
</br>
PortAudioPort playSweep</br>
MIDIPort testANote</br>
MIDIPort testBend</br>
MIDIVoice scaleExample</br>
</p><hr><h3 id="BuildingSireninCuis6">34 - Building Siren in Cuis 6</h3>Script to build Siren9C in Cuis</br>
&emsp;Do not file this in - step through the blocks 1 by 1</br>
</br>
Set-up</br>
</br>
Load themes, choose light theme</br>
Choose small GUI features</br>
Set font Computer Modern Serif</br>
</br>
Load packages - optional for now</br>
</br>
[&emsp;Feature require: 'Network-Kernel'.</br>
&emsp;Feature require: 'FFI.pck.st'.</br>
&emsp;Feature require: 'Tests-FFI.pck.st'.</br>
&emsp;Feature require: 'Sound.pck.st' ]</br>
</br>
STP world file-ins (Edit the relative paths below to suit your installation)</br>
</br>
[ #(</br>
&emsp;'GUI-changes.st'</br>
&emsp;'ST80-compatibility.st'</br>
&emsp;'SixPanedBrowser.st'</br>
&emsp;'SixPanedBrowserWindow.st'</br>
&emsp;'WorkbookWindow.st'</br>
&emsp;'ZPoint.st'</br>
) do: [ :file |</br>
&emsp;Transcript show: 'Filing in ', file; cr.</br>
&emsp;('./Siren9C/FileIns/', file) asFileEntry readStreamDo: </br>
&emsp;&emsp;[ :stream | stream ifNotNil: [stream fileIn]]]]</br>
</br>
Siren file-ins using packages (WIP) or source code files (works)</br>
</br>
[ "In the future - use packages"</br>
&emsp;Feature require: 'Music-Support.pck.st'.</br>
&emsp;Feature require: 'MusicUI-DisplayListViews.pck.st'.</br>
&emsp;Feature require: 'MusicIO-MIDI.pck.st' ]</br>
</br>
OR src code file-in (Edit the relative paths below to suit your installation)</br>
</br>
[</br>
&emsp;'./Siren9C/FileIns/SirenSystemChanges.st' asFileEntry readStream fileIn.</br>
&emsp;</br>
#(&emsp;'Music-Models-Representation.st'</br>
&emsp;'Music-Models-Implementation.st'</br>
&emsp;'Music-Events.st'</br>
&emsp;'Music-EventGenerators.st'</br>
&emsp;'Music-EventModifiers.st'</br>
&emsp;'Music-Functions.st'</br>
"&emsp;'Music-Sound.st'</br>
"&emsp;'Music-PitchScales.st'</br>
&emsp;'Music-PitchClasses.st'</br>
&emsp;'Music-Support.st'</br>
</br>
&emsp;'MusicIO-Voices.st'</br>
&emsp;'MusicIO-OSC.st'</br>
&emsp;'MusicIO-MIDI.st'</br>
</br>
&emsp;'MusicUI-DisplayLists.st'</br>
&emsp;'MusicUI-DisplayListViews.st'</br>
&emsp;'MusicUI-Layout.st'</br>
&emsp;'MusicUI-Editors.st'</br>
&emsp;</br>
) do: [ :file |</br>
&emsp;Transcript show: 'Filing in ', file; cr.</br>
&emsp;('./Siren9C/SirenSources/', file) asFileEntry readStreamDo: </br>
&emsp;&emsp;[ :stream | stream ifNotNil: [stream fileIn]]].</br>
&emsp;</br>
&emsp;'./Siren9C/FileIns/MusicConstants.st' asFileEntry readStream fileIn.</br>
]</br>
</br>
Clean up</br>
</br>
[&emsp;Duration initialize.</br>
&emsp;Pitch initialize.</br>
&emsp;Amplitude initialize.</br>
]</br>
</br>
Rename categories for Themes and VectorEngineInSmalltalk etc. to be under Graphics or Morphic (for better 6-paned browsing)</br>
</br>
[ WorkbookWindow openFolder: './Siren9C/Workbook' named: 'Siren Workbook' ]</br>
</br>
Undeclared inspect</br>
Smalltalk garbageCollect</br>
</br>
Screen background image</br>
</br>
[self runningWorld backgroundImageData:</br>
&emsp;(UniFileStream new open: '/Users/stp/Code/Smalltalk/Siren9C/display-lite.jpg' forWrite: false) </br>
&emsp;binary contentsOfEntireFile]</br>
</br>
ToDo</br>
</br>
DisplayList editing</br>
OSC I/O via sockets</br>
MIDI I/O via plug-in</br>
Function & Sound editors</br>
</p><hr><h3 id="BuildingSireninSqueak6">35 - Building Siren in Squeak 6</h3>Script to build Siren in Cuis (Version 9C)</br>
&emsp;Do not file this in - step through the blocks 1 by 1</br>
</br>
Set-up</br>
</br>
Use the Squeak customization process.</br>
</br>
</br>
STP world file-ins (Edit the relative paths below to suit your installation)</br>
</br>
[ #(</br>
&emsp;'ZPoint.st'</br>
&emsp;'SirenSystemChanges.st'</br>
&emsp;'SqueakChanges.st'</br>
&emsp;'WorkbookWindowSqueak.st'</br>
) do: [ :file |</br>
&emsp;Transcript show: 'Filing in ', file; cr.</br>
&emsp;(FileStream fileNamed: ('./Siren9C/FileIns/', file)) fileIn]]</br>
</br>
[#(&emsp;'Music-Models-Representation.st'</br>
&emsp;'Music-Models-Implementation.st'</br>
&emsp;'Music-Events.st'</br>
&emsp;'Music-EventGenerators.st'</br>
&emsp;'Music-EventModifiers.st'</br>
&emsp;'Music-Functions.st'</br>
"&emsp;'Music-Sound.st'&emsp;"</br>
&emsp;'Music-PitchScales.st'</br>
&emsp;'Music-PitchClasses.st'</br>
&emsp;'Music-Support.st'</br>
</br>
&emsp;'MusicIO-Voices.st'</br>
&emsp;'MusicIO-OSC.st'</br>
&emsp;'MusicIO-MIDI.st'</br>
</br>
&emsp;'MusicUI-DisplayLists.st'</br>
&emsp;'MusicUI-DisplayListViews.st'</br>
&emsp;'MusicUI-Layout.st'</br>
&emsp;'MusicUI-Editors.st'</br>
&emsp;</br>
) do: [ :file |</br>
&emsp;Transcript show: 'Filing in ', file; cr.</br>
&emsp;(FileStream fileNamed: ('./Siren9C/Siren9C_Sources_Squeak/', file)) fileIn]].</br>
&emsp;&emsp;&emsp;&emsp;&emsp;"Broken - GUI port still WIP"</br>
&emsp;&emsp;(FileStream fileNamed: './Siren9C/FileIns/MusicConstants.st') fileIn</br>
]</br>
</br>
Clean up</br>
</br>
[&emsp;MDuration initialize.</br>
&emsp;Pitch initialize.</br>
&emsp;Amplitude initialize.</br>
]</br>
</br>
Rename categories for Themes and VectorEngineInSmalltalk etc. to be under Graphics or Morphic (for better 6-paned browsing)</br>
</br>
[WorkbookWindow openFolder: './Siren9C/Workbook/' named: 'Siren Workbook']</br>
</br>
</br>
Undeclared inspect</br>
Smalltalk garbageCollect</br>
</br>
ToDo</br>
</br>
DisplayList editing</br>
OSC I/O via sockets</br>
MIDI I/O via plug-in</br>
Function & Sound editors</br>
</p><hr><h3 id="RelatedSoftware">36 - Related Software</h3>Related Software</br>
</br>
Siren is typically used in consort with a number of other packages; for more information, see the links below</br>
</br>
CSL: the CREATE Signal Library: a C++ framework for building OSC-controllable synthesis/processing servers</br>
&emsp;http://FASTLabInc.com/CSL</br>
</br>
Loris: a sound analysis/resynthesis package written by Kelly Fitz</br>
&emsp;http://sourceforge.net/projects/loris</br>
</br>
SuperCollider: an efficient synthesis and processing language very similar to Smalltalk</br>
&emsp;http://supercollider.sourceforge.net/</br>
</br>
CRAM: the CREATE Real-time Applications Manager: a tool for describing and managing complex distributed real-time software systems</br>
&emsp;http://FASTLabInc.com/CRAM</br>
</br>
Occam: An OSC-to-MIDI translator</br>
&emsp;http://www.mat.ucsb.edu/~c.ramakr/illposed/occam.html</br>
</br>
Macco: a MIDI-to-OSC convertor</br>
&emsp;http://FASTLabInc.com/CSL/Macco.zip</br>
</br>
FMAK: the FASTLab Music analysis Kernel (a sibling of CSL)</br>
&emsp;http://FASTLabInc.com/</br>
</br>
libSndFile: http://www.mega-nerd.com/libsndfile</br>
</br>
PortMidi: http://www.cs.cmu.edu/~music/portmusic</br>
</br>
PortAudio: http://www.portaudio.com</br>
</br>
FFTW: the fastest FFT in the west</br>
&emsp;http://www.fftw.org</br>
</br>
JUCE: the great C++ library for multimedia</br>
&emsp;http://www.juce.com</br>
</p><hr><h3 id="ReleaseNotesandVersionHistory">37 - Release Notes and Version History</h3>Siren 9.0 Release Notes</br>
</br>
Current Status</br>
</br>
This is the V9.0 release of Siren on VisualWorks. (For simplicity, Siren version numbers parallel the versions of Smalltalk on which they run.)</br>
</br>
Smoke: The Smoke representation is complete, see the event list and event generator examples.</br>
</br>
Voices and Schedulers: The scheduler delivers acceptable real-time performance on a modern CPU. The real-time output via OSC or MIDI is suitable for use in performance.</br>
</br>
Sound I/O: Sound file I/O is implemented for many kinds of sound files (AIFF, WAV, .snd, etc.) via the libSndFile interface. There is a PortAudio callback interface using DLLCC as well as an FFTW interface for the class Spectrum</br>
</br>
MIDI/OSC: Ports and Voices exist for real-time control I/O.</br>
</br>
There are DLLCC interfaces to CSL and Loris based on SWIG interfaces.</br>
</br>
Graphics and GUI: The display list framework, Navigator MVC framework, and several MVC-based GUI tools are available; see the examples above.</br>
</br>
Version History</br>
</br>
Siren on Visualworks</br>
&emsp;9.0--FASTLab, Santa Barbara, May, 2020</br>
&emsp;7.6--FASTLab, Santa Barbara, January, 2013</br>
&emsp;7.5--CREATE, Santa Barbara, April, 2007</br>
&emsp;7.4--CREATE, Santa Barbara, Winter, 2006</br>
&emsp;7.3--CREATE, Santa Barbara, throughout 2005</br>
&emsp;7.2--CREATE, Santa Barbara, Fall, 2003</br>
&emsp;7.0--CREATE, Santa Barbara, Spring, 2001</br>
</br>
Siren on Squeak</br>
&emsp;3.0--T. U. Berlin, Summer, 2000</br>
&emsp;2.2--CREATE, October/November, 1998</br>
&emsp;2.0--CREATE, April-June, 1998</br>
&emsp;1.3--CREATE, August/September, 1997</br>
&emsp;1.0--CREATE, December, 1996</br>
</br>
MODE </br>
&emsp;2.0--(Topaz2) CNMAT/Berkeley, April - December, 1994</br>
&emsp;1.3--(Topaz) SICS/EMS, Stockholm, February - April, 1993</br>
&emsp;1.2--CCRMA/Stanford, July, 1991 - February, 1992</br>
&emsp;1.0--STEIM, Amsterdam, May/June 1990</br>
&emsp;0.8--CCRMA/Stanford, June, 1989</br>
&emsp;0.4--ParcPlace Systems, March, 1988</br>
</br>
HyperScoreToolKit</br>
&emsp;1.0--Xerox PARC, October, 1986</br>
</br>
DoubleTalk</br>
&emsp;1.0--PCS/Cadmus GmbH, October, 1984</br>
</p><hr><h3 id="ReferencesandAcknowledgments">38 - References and Acknowledgments</h3>Reference, Acknowledgments</br>
</br>
The main Siren Web site is at http://FASTLabInc.com/Siren.</br>
This outline is on-line at http://FASTLabInc.com/Siren/Doc.</br>
To join the mailing list, see http://www.create.ucsb.edu/mailman/listinfo/Siren.</br>
</br>
To read more about computer music, get a copy of Curtis Roads' "Computer Music Tutorial" (MIT Press).</br>
</br>
To learn more about Smalltalk, see the several excellent on-line Smallatlk tutorials (just ask Google) e.g.,</br>
&emsp;http://www.cincomsmalltalk.com/tutorials/version7/tutorial1/home.htm</br>
&emsp;http://www.smalltalk.org</br>
&emsp;http://www.squeak.org</br>
&emsp;http://www.cosc.canterbury.ac.nz/~wolfgang/cosc205/smalltalk1.html</br>
&emsp;http://daitanmarks.sourceforge.net/or/squeak/squeak_tutorial.html</br>
&emsp;http://www.sra.co.jp/people/aoki/htmls/FreeDocumentsForSmalltalk.html</br>
</br>
The Squeak CD-ROM (http://www.squeak.org/Download/SqueakCD) has a whole collection of good Smalltalk tutorials.</br>
</br>
Acknowledgments</br>
</br>
Siren incorporates the work of many people who have contributed ideas and/or code; it would be most unfair not to acknowledge them here. They include:</br>
&emsp;Paul Alderman</br>
&emsp;Alberto de Campo</br>
&emsp;Roger Dannenberg</br>
&emsp;Lounette Dyer</br>
&emsp;Adrian Freed</br>
&emsp;Guy Garnett</br>
&emsp;Kurt Hebel</br>
&emsp;Frode Holm</br>
&emsp;Helge Horch</br>
&emsp;Dan Ingalls</br>
&emsp;Craig Latta</br>
&emsp;David Leibs</br>
&emsp;Mark Lentczner</br>
&emsp;Hitoshi Katta</br>
&emsp;Alex Kouznetsov</br>
&emsp;John Maloney</br>
&emsp;James McCartney</br>
&emsp;Hans-Martin Mosner</br>
&emsp;Luciano Notarfrancesco</br>
&emsp;Danny Oppenheim</br>
&emsp;Nicola Orio</br>
&emsp;Francois Pachet</br>
&emsp;Andreas Raab</br>
&emsp;Chandrasekhar Ramakrishnan</br>
&emsp;Pierre Roy</br>
&emsp;Carla Scaletti</br>
&emsp;Bill Schottstaedt</br>
&emsp;John Tangney</br>
&emsp;Bill Walker</br>
</br>
I must also here acknowledge the generous support of my employers and the academic institutions where this software (and its predecessors) was developed, including CMRS@Mozarteum/Salzburg (1980-85), PCS/Cadmus GmbH in Munich (1983-6), Xerox PARC (1986-89), ParcPlace Systems, Inc. (1988-94), CCRMA@Stanford (1986-92), the STEIM Foundation in Amsterdam (1990-91), the Swedish Institute for Computer Science (1992-93), CMNAT@UC Berkeley (1993-95),  CREATE@UC Santa Barbara (1996-2006), and the Technical University of Berlin (2000).</br>
</p><hr><h3 id="LearningtoReadSmalltalk">39 - Learning to Read Smalltalk</h3>A Note on Reading the Smalltalk-80 Programming Language</br>
</br>
(stp - 12/91)</br>
</br>
Smalltalk-80 is a message-passing object-oriented programming language where expressions are built to be read as English sentences. The language is based on the concepts of objects (software modules that consist of state [data] and behavior [procedures]), that send messages among each other. All data is organized into objects, and all functionality is described as the behaviors of objects. A Smalltalk- 80 application is a network of objects.</br>
</br>
Objects that have similar state and behaviors are grouped into classes (e.g., the class of all whole numbers [integers], or the class of all 2-dimensional Cartesian points). The classes themselves are arranged into a tree-like sub/superclass hierarchy with inheritance of state and behavior from a superclass to its subclasses (e.g., the class of integers might be defined as a subclass of the class of numbers).</br>
</br>
Names and identifiers are separated by white space and are often composed of a concatenated noun phrase written with embedded upper-case letters, e.g., anEvent or MusicMagnitude. </br>
</br>
In a Smalltalk-80 expression, the noun (i.e., the receiver object), comes first, followed by the message; e.g., to ask the size of an array, one sends it the message "size," as in [anArray size]. </br>
</br>
If the message has any arguments, they are separated from the message keywords in that the keywords all end in ":", so to index the first element of the array, one writes [anArray at: 1]; to set it to zero, use [anArray at: 1 put: 0]. </br>
</br>
Binary operators are allowed for mathematical (+, *, etc.) and logic (>, ~=, etc) operations.</br>
</br>
Expressions can be nested using parentheses (i.e., evaluate what's inside the inner-most parentheses first), and fancy expression constructs and control structures are possible.</br>
</br>
Expression examples</br>
</br>
&emsp;Unary messages - [receiver message]</br>
&emsp;&emsp;anArray size</br>
&emsp;&emsp;Date today&emsp;&emsp;&emsp;&emsp;"message to a class"</br>
&emsp;&emsp;x negated</br>
</br>
&emsp;Binary messages - [receiver operation operand]</br>
&emsp;&emsp;3 + 4.2215</br>
&emsp;&emsp;x > 7&emsp;&emsp;&emsp;&emsp;&emsp;"answers true or false"</br>
&emsp;&emsp;(a + b) * (c + d)</br>
</br>
&emsp;Keyword messages - [receiver keyword: operand]</br>
&emsp;&emsp;anArray at: 1&emsp;&emsp;&emsp;&emsp;"get an item from an array"</br>
&emsp;&emsp;anArray at: 1 put: 7&emsp;&emsp;&emsp;"assign into an array"</br>
&emsp;&emsp;aVisualItem displayOn: aMedium at: aPoint clip: aClipRect mask: aMask</br>
&emsp;(messages called  at:put:  or  displayOn:at:clip:mask:)</br>
</br>
Unary expressions can be concatenated, as in</br>
&emsp;Date today weekday size odd printString</br>
</br>
which answers the string "true" or "false," as though it were written,</br>
&emsp;((((Date today) weekday) size) odd) printString</br>
</br>
Unary messages bind more strongly than binary messages, as in,</br>
&emsp;3 negated * 4 sqrt&emsp;&emsp;&emsp;"answers -6 "</br>
this is read as</br>
&emsp;(3 negated) * (4 sqrt)</br>
</br>
Keywords bind the weakest, so that the expressions,</br>
&emsp;Transcript show: aNumber printString, ' is not equal to ', otherNumber printString.</br>
&emsp;anArray at: index + 1 put: 'hello ', ' world'.</br>
are to be read as,</br>
&emsp;Transcript show: ((aNumber printString), ' is not equal to ', (otherNumber printString)).</br>
&emsp;anArray at: (index + 1) put: ('hello ', ' world').</br>
</br>
A single expression can contain at most one keyword message, i.e., the compiler always tries to build the longest composed keyword message it can find in an expression. For example, to copy an element from one position in an array to another, we would have to parenthesize the 2 keyword messages, as follows,</br>
&emsp;anArray at: 1 put: (anArray at: 2)</br>
because without the parentheses, the message would be interpreted as at:put:at: (which is probably not implemented).</br>
</br>
When several messages are to be sent to the same receiver, and the return values are ignored, one can create a message cascade" by separating the messages with semi-colons instead of periods, and not repeating the receiver, as in,</br>
&emsp;Transcript show: name printString.</br>
&emsp;Transcript cr.</br>
which can be written as a cascade or 2 messages sent to Transcript,</br>
&emsp;Transcript show: name printString ; cr.</br>
</br>
Comments</br>
</br>
Double-quotes delineate comments in Smalltalk-80 (e.g., "a comment"); single-quotes are used for string objects (e.g., 'a string'). </br>
</br>
Naming</br>
</br>
Most variable and message names start with lower-case letters and may contain embedded upper-case latters (camelCase) as in the examples above.</br>
</br>
Global-scope objects such as namespaces, shared variables and classes are typically capitalized, as in Date, OrderedCollection, or Siren.Sound (a class name in a namespace).</br>
</br>
Names for temporary variables are declared between vertical bars (e.g.,  | varName1 varName2 | ). </br>
</br>
Symbols are special strings that are stored in a table so as to be unique; they are written with the hash-mark "#" as in #blue, meaning "the symbol blue."</br>
</br>
Immediate Object Formats</br>
</br>
&emsp;Integer&emsp;&emsp;7&emsp;&emsp;&emsp;&emsp;244361990863443121 </br>
&emsp;Real&emsp;&emsp;&emsp;3.1415926&emsp;&emsp;2.8879044346233</br>
&emsp;Character&emsp;&emsp;$a &emsp;&emsp;&emsp;&emsp;$.</br>
&emsp;String&emsp;&emsp;'hi'&emsp;&emsp;&emsp;&emsp;'longer string'</br>
&emsp;Symbol&emsp;&emsp;#hi&emsp;&emsp;&emsp;&emsp;#SymbolicValue</br>
</br>
&emsp;List (Collection)&emsp;&emsp;#(a b c)</br>
&emsp;Association&emsp;&emsp;( a -> b)&emsp;&emsp;&emsp;"key/value tuple"</br>
&emsp;Dictionary (Map)&emsp;(a -> b), (c -> d)&emsp;"like a hash map"</br>
</br>
&emsp;Logical constants&emsp;true, false, nil</br>
</br>
Control Structures</br>
</br>
Smalltalk supports deferred execution in the form of closures or anonymous functions called blocks; they are written in square brackets "[...]" and can have arguments and/or local temporary variables. </br>
</br>
The up-arrow or caret (^) is used to return values (objects) from within blocks. </br>
</br>
A block that takes two arguments and returns their sum would look like:</br>
&emsp;[ "arguments" :x :y | "body" ^(x + y)].</br>
</br>
Since Boolean objects and blocks are supported, it's easy to define the standard program logical control flow operations such as if/then/else or do/while. Here are examlpes in Smalltalk</br>
</br>
&emsp;(x < 0) ifTrue: [x := x negated]&emsp;&emsp;&emsp;"like if (x < 0) { x = 0 - x; };"</br>
&emsp;(x < 0) ifTrue: [x := x negated]&emsp;&emsp;&emsp;"like if (x < 0) { } else { }"</br>
&emsp;&emsp;&emsp;ifFalse: [x := x - 1]</br>
</br>
For loop: use x to: y do: [block-with-1-argument]</br>
&emsp;1 to: 10 do: [ :index | Transcript show: index printString; cr]</br>
</br>
While loop</br>
&emsp;[x > 0] whileTrue: [Transcript show x printString; cr.  x := x - 1]</br>
</br>
Collection iteration</br>
&emsp;#(1 3 5 7 9) do: [ :item | "block " ]</br>
&emsp;aSet select: [ :item | item > 0 ]</br>
</br>
The format of a method; the browser uses a standard code template for new methods</br>
</br>
&emsp;methodName: argument</br>
&emsp;&emsp;"Comment stating purpose and return value."</br>
</br>
&emsp;&emsp;| tempVarName |</br>
&emsp;&emsp;method body statements.</br>
&emsp;&emsp;^self &emsp;&emsp;&emsp;"some return value"</br>
</br>
Short-hand and Important Messages</br>
</br>
&emsp;#x - the symbol with the name x</br>
</br>
&emsp;#(a b c) - an Array with members a, b, & c</br>
</br>
&emsp;x -> y - an Association (x = key, y = value)</br>
</br>
&emsp;x @ y - a Point with X = x and Y = y</br>
</br>
The Protocol of All Objects</br>
</br>
There are many methods implemented in class Object that are understood by everyong in the system (i.e., you can send them to self in any method).</br>
&emsp;basicAt:, basicAt:Put: - encapsulation-breaking low-level access</br>
&emsp;halt - a breakpoint to get into a debugger</br>
&emsp;inspect - look inside the receiver</br>
&emsp;printString - pretty-print the receiver</br>
&emsp;storeOn: - serialize the receiver on a stream</br>
</br>
All classes understand some useful instance-accessing messages</br>
&emsp;instanceCount - how many of me are there?</br>
&emsp;allInstances - get them all</br>
&emsp;someInstance - pick one</br>
</br>
The Class Library</br>
</br>
Smalltalk includes a rich class library, the main abstractions of which are listed below.</br>
</br>
Magnitudes - understand comparison operators</br>
&emsp;Subclasses like ArithmeticValue, Point, Number, SmallInteger, etc.</br>
&emsp;(arbitrary-precision integers, fractions, meta-numbers)</br>
</br>
Collections - aggregate objects such as arrays and hash maps</br>
&emsp;Set, Dictionary, OrderedCollection, SortedCollection, Array</br>
&emsp;Understand size includes:, do: collect: select:</br>
</br>
Streams - read/write streaming I/O, used for files, sockets, etc.</br>
&emsp;Understand next (read something) and nextPut: (write)</br>
</br>
Model/View/Controller - classes for the MVC design pattern used in GUIs</br>
</br>
Networking and Protocols - Support for formatted streams</br>
</br>
UI Support - ApplicationModel, Dialog</br>
</br>
Compilers - Compiler tools</br>
</br>
Programming</br>
</br>
Smalltalk programs are organized as the behaviors (methods) of classes of objects. To program a graphical application, for example, one might start by adding new methods to the point and 3-D point classes for graphical transformations, and build a family of "smart" visible display objects that know how to present themselves in interesting ways. </br>
</br>
Classes are described as being abstract or concrete depending on whether they are meant as models for refinement within a framework, or for reuse "off the shelf" as in the elements in a tool kit.</br>
</br>
Inheritance means that classes of objects are related in hierarchies (i.e., abstract and concrete classes related in trees), where they share their methods and state variables. This means that the class of 3-D points only has to add the z- coordinate and a few new methods when it's defined as being a specialization (subclass) of the 2-D point class.</br>
</br>
Polymorphism means that many kinds of objects respond to the same message with their own methods to carry out related behavior. Examples are the "play" message being handled by event lists in terms of being passed on to their component events in real-time, or of displayable objects and windows all having methods for the "display" message.</br>
</br>
Inheritance and polymorphism mean that one reads Smalltalk-80 programs by learning the basic protocol (messages/methods) of the abstract classes first; this gives one the feel for the basic behaviors of the systems's objects and applications.</br>
</br>
To actually work in Smalltalk, one generally writes code in browsers, then uses inspectors to create and manipulate objects during testing. One can also write tests and demonstrations as class example methods. There are many browser and debugger features that encourage extreme and exploratory programming. Code generally lives in a database and can be easily shared through the various Internet-based code repositories such as Store or Envy.</br>
</br>
For more info, there are several excellent on-line Smallatlk tutorials (just ask Google), see the reference section of this workbook. The Squeak CD-ROM (http://www.squeak.org/Download/SqueakCD) has a whole collection of good Smalltalk tutorials.</br>
</p><hr><h3 id="Bugs&ThingsToDo">40 - Bugs & ThingsToDo</h3>Known bugs</br>
</br>
There are certainly many bugs in Siren.</br>
</br>
Some of the demos don't work any more; sorry.</br>
</br>
The SWIG code is no longer supported.</br>
</br>
The old ManualWriter and ComposedTextEditor packages have disappeared, so the list workbook is single-font and can't create web pages any more.</br>
</br>
The MIDI and Sound I/O should probably be rewritten to use JUCE or some other modern APIs.</br>
</br>
The PortAudio sound output is pretty distorted; I should look into the buffer-passing code.</br>
</br>
The display list views have no notion of pages, so longer musical examples don't display well. We need a fancier document model with page layout.</br>
</br>
</br>
ToFixASAP</br>
</br>
Ostinato doesn't wait right.</br>
</br>
Browser: colors wrong on class/inst switches</br>
</br>
FullSystemBrowser: can't compile if no protocol selected, gives "Nothing more expected ->" error</br>
</br>
</br>
For VW 9.0</br>
</br>
Port workspace outliner to new framework used by system doc window</br>
</br>
Port full system browser to not require OldBrowsers package</br>
</p><hr><h3 id="Workspace">41 - Workspace</h3>Test Workspace</br>
</br>
[WorkbookWindow openFolder: './Siren_Cuis/Workbook' </br>
&emsp;named: 'Siren Workbook' ].</br>
</br>
Undeclared inspect.</br>
Smalltalk garbageCollect.</br>
Utilities openUsefulExpressions.</br>
DirectoryEntry currentDirectory.</br>
</br>
--------------------------</br>
</br>
[DisplayListView exampleRectangles].</br>
[DisplayListView exampleLines].</br>
[DisplayListView examplePolylines].</br>
[DisplayListView exampleVisuals].</br>
[DisplayListView exampleMixed].</br>
[DisplayList exampleHierarchical display]</br>
[DisplayVisual displayMusicConstants].</br>
</br>
[TimeSequenceView randomExample]</br>
[PitchTimeView randomExample]</br>
[HauerSteffensView randomExample]</br>
[DynamicCloud focusExample]</br>
</br>
--------------------------</br>
</br>
FFIPluginTests new testLoadSymbolFromModule</br>
Smalltalk browseAllCallsOn: (Undeclared associationAt: #A)</br>
</br>
--------------------------</br>
</br>
Squeak testing</br>
</br>
"(EventList scaleFrom: 48 to: 60 in: 1.5) asSoundScore play"</br>
" | sco voxs| </br>
&emsp;sco := EventList scaleFrom: 48 to: 60 in: 1.5.</br>
&emsp;voxs := Array with: FMSound oboe1 with: FMSound brass1 </br>
&emsp;&emsp;&emsp;with: FMSound marimba with: PluckedSound default.</br>
&emsp;sco eventsDo: [ :ev |</br>
&emsp;&emsp;ev voice: voxs atRandom].</br>
&emsp;sco asSoundScore play&emsp;"</br>
</br>
Roll tests</br>
</br>
((Roll length: 6000 rhythm: 60 note: 60) ampl: 100) eventList asSoundScore play</br>
((Roll length: 6000 rhythm: 60 note: 60) ampl: 100) eventList playOn: MIDIVoice default</br>
((Roll length: 6000 rhythm: 60 note: 60) ampl: 100) eventList </br>
&emsp;&emsp;playOn: OSCVoice cslHost: pMapForCSLSimpleFM</br>
</br>
----</br>
</br>
MacOSShell new getenv: 'HOME' </br>
OSProcess fileExists: '/Users/stp/.profile' </br>
OSProcess isUnixMac</br>
</br>
CStandardLibrary checkCStandardLibrary </br>
CStandardLibrary new abs: -42 </br>
</br>
PortMIDILibrary new pm_count_devices </br>
PortMIDILibrary new pm_default_input_device  0 </br>
PortMIDILibrary new pm_default_output_device  3 </br>
PortMIDILibrary new pm_test: PortMIDILibrary new pm_default_output_device </br>
PortMIDILibrary listDeviceTable</br>
PortMIDILibrary testAllNotes</br>
ExternalLibrary clearAllCaches.</br>
PortMIDILibrary new pm_terminate</br>
MIDIVoice scaleExample</br>
MIDIVoice randomExample</br>
</br>
EventScheduler interrupt; flush</br>
OSCVoice fmExample2</br>
EventScheduler flush</br>
OSCVoice fmExample1</br>
OSCVoice fmExample2</br>
OSCVoice pluckExample1</br>
OSCVoice sndExample1</br>
OSCVoice sndExample2</br>
OSCVoice sharcExample1</br>
OSCVoice bellExample1</br>
OSCVoice vSOSExample1</br>
</br>
----</br>
</br>
Undeclared inspect</br>
Smalltalk garbageCollect</br>
&emsp;[MIDIPort allNotesOff]</br>
&emsp;[MIDIPort cleanUp]</br>
</br>
Default CSL Synthesis Server Instruments (see CSL7/Src/IO/OSC_main.cpp)</br>
</br>
&emsp;1 - 10 ---- 10 plucked strings</br>
&emsp;&emsp; "fff" - amp, pitch, pos</br>
&emsp;11 - 20 ---- 10 FM instruments</br>
&emsp;&emsp;"ffff" - dur amp pitch pos</br>
&emsp;&emsp;"ffffff" - dur, ampl, c_fr, m_fr, ind, pos</br>
&emsp;21 - 30 ---- 10 FM bells</br>
&emsp;&emsp; "fffffff" - dur, ampl, pitch,  gliss, rat,  ind,  pos</br>
&emsp;31 - 34 ---- 4 sound files (words)</br>
&emsp;&emsp;"ff" - amp, pos</br>
&emsp;35 - 50 ---- 16 SHARC SOS voices (different instruments)</br>
&emsp;&emsp;dur, ampl, pitch, pos</br>
&emsp;&emsp;dur, ampl, pitch, pos, att, dec, sus, rel</br>
&emsp;51 - 55 ---- 5 basic SHARC-spectrum instruments w vibrato</br>
&emsp;&emsp;dur, ampl, pitch, pos</br>
&emsp;&emsp;dur, ampl, pitch, pos, att, dec, sus, rel</br>
&emsp;56 - 61 ---- 5 SHARC-instrument additive cross-fade instruments w vibrato</br>
&emsp;&emsp;dur, ampl, pitch, pos</br>
&emsp;&emsp;dur, ampl, pitch, pos, att, dec, sus, rel</br>
</br>
--------------------------</br>
</br>
File-out</br>
</br>
[SirenUtility fileoutCategories]</br>
</br>
As packages</br>
</br>
[SirenUtility categoryList do: </br>
&emsp;[ :cat |</br>
&emsp;(CodePackage named: cat</br>
&emsp;&emsp;createIfAbsent: true </br>
&emsp;&emsp;registerIfNew: true) save] ]</br>
&emsp;</br>
</p></p><HR><p>